

limit = false
targetInfo = gg.getTargetInfo()
app = targetInfo.packageName
filename = gg.getFile():match("[^/]+$")
if filename ~= "#8[Fast-Decrypt]_𝐈𝐭'𝐱_𝐅𝐚𝐡𝐢𝐦.lua" then
  print("⚠ 𝐃𝐨 𝐧𝐨𝐭 𝐜𝐡𝐚𝐧𝐠𝐞 𝐟𝐢𝐥𝐞 𝐧𝐚𝐦𝐞 , 𝐩𝐥𝐞𝐚𝐬𝐞 𝐫𝐞𝐬𝐭𝐨𝐫𝐞 𝐭𝐨 𝐨𝐫𝐢𝐠𝐢𝐧𝐚𝐥 𝐧𝐚𝐦𝐞!\n♛ 𝐎𝐫𝐢𝐠𝐢𝐧𝐚𝐥 𝐍𝐚𝐦𝐞 ➤☟︎︎︎\n#8[Fast-Decrypt]_𝐈𝐭'𝐱_𝐅𝐚𝐡𝐢𝐦.lua")
  os.exit()
end


-- Check status from GitHub
local currentVersion = "1.0" -- Change this when releasing new versions

-- 🔗 Remote JSON config
local configURL = "https://raw.githubusercontent.com/Fahim558/Project-1/main/script_config.json"
local configReq = gg.makeRequest(configURL)

if not configReq.content then
    gg.alert("❌ Cannot connect to server. Check your internet.")
    os.exit()
end

-- 🔄 Parse JSON (manual method)
local ok, config = pcall(function() return load("return " .. configReq.content)() end)
if not ok or not config then
    gg.alert("❌ Invalid config format.")
    os.exit()
end

-- 🚫 Remote OFF
if config.status ~= "on" then
    gg.alert("🚫 Script is OFF by the developer.")
    os.exit()
end

-- 🔄 Version mismatch
if config.version ~= currentVersion then
    local force = config.force_update or false

    gg.alert("🆕 Update Required!\n\n📌 New Version: " .. config.version ..
             "\n\n" .. (config.changelog or "No changelog."))

    if force then
        gg.alert("⚠️ You must update to continue...")

        local updateReq = gg.makeRequest(config.update_url)
        if updateReq.content then
            -- ⚠️ OVERWRITE current script
            local scriptPath = "/storage/emulated/0/Download/#8[Fast-Decrypt]_𝐈𝐭'𝐱_𝐅𝐚𝐡𝐢𝐦.lua"
            local f = io.open(scriptPath, "w")
            f:write(updateReq.content)
            f:close()
            gg.alert("✅ Updated successfully!\nFile overwritten:\n*#8[Fast-Decrypt]_𝐈𝐭'𝐱_𝐅𝐚𝐡𝐢𝐦.lua*")
        else
            gg.alert("❌ Failed to download update.")
        end
        os.exit()
    end
end

-- ✅ Continue if latest
gg.alert("✅ Script is ON (v" .. currentVersion .. "). Welcome!")



-- 🔽 Ekhane tumar main menu/function add koro


gg.setVisible(true)
LuaLibraryTool = -1
function HOME()
  local menu = gg.multiChoice({
    "✅ HTTP CUSTOM [1]",
    "✅ HTTP CUSTOM [2]",
    "✅ HTTP CUSTOM [3]",
    "✅ HTTP CUSTOM [JSON]",
    "✅ HTTP CUSTOM [BETA]",
    "✅ V2RAY ALL [1]",
    "✅ V2RAY ALL [2]",
    "✅ HC UDP",
    "✅ HC SSH",
    "✅ PSIPHON",
    "✅ SSC CUSTOM [NORMAL]",
    "✅ SSC CUSTOM {JSON}",
    "✅ NPVT V2RAY [1]",
    "✅ NPVT V2RAY [2]",
    "✅ NPVT SSH",
    "✅ SocksIP",
    "✅ TLS TUNNEL",
    "✅ DARK TUNNEL [1]", 
    "✅ DARK TUNNEL [2]",     
    
    "❌ EXIT"
  }, nil, os.date([[
┏━━━━━━━━━━━━━━━━━━━━━━┓
┃𝗖𝗢𝗗𝗘 𝗕𝗬 ⧼ 𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿_𝗫_𝗙𝗔𝗛𝗜𝗠 ⧽
┃𝗚𝗥𝗢𝗨𝗣 : t.me/Decrypt_VPN_Files 
┃𝗨𝗡𝗟𝗢𝗖𝗞 𝗧𝗢𝗢𝗟𝗦
┗━━━━━━━━━━━━━━━━━━━━━━┛

┏━━━━━━━━━━━━━━━━━━━━━━┓
┃••••••••••••𝗨𝗡𝗟𝗢𝗖𝗞 𝗧𝗢𝗢𝗟𝗦••••••••••••
┗━━━━━━━━━━━━━━━━━━━━━━┛

]]))

  if menu == nil then return end

  if menu[1] then HTTPCustom() end
  if menu[2] then HC() end
  if menu[3] then HTTP3() end  
  if menu[4] then HTTPCUSTOM3() end
  if menu[5] then HcDNS() end
  if menu[6] then V2RAY() end
  if menu[7] then V2RAY2() end 
  if menu[8] then UDPNEW() end 
  if menu[9] then SSHDEC() end
  if menu[10] then Fahim() end
  if menu[11] then SSCCustom() end
  if menu[12] then SSC() end
  if menu[13] then Npvtv2ray() end 
  if menu[14] then NpvtV2RAY2() end  
  if menu[15] then NpvtSSH() end 
  if menu[16] then sip() end  
  if menu[17] then tls() end  
  if menu[18] then DarkTunnel() end   
  if menu[19] then darktunnel2() end      
  if menu[20] then LOBBY() end
end

LuaLibraryTool = -1



function SSC()
  gg.clearResults()
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setVisible(false)
  gg.setSpeed(20.0)
  gg.searchNumber(':{"ab', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺")
    ssc_method2 = true
  end
  if ssc_method2 then
    gg.searchNumber("h 55 70 67 72 61 64 65 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺")
      ssc_method3 = true
    end
  end
  if ssc_method3 then
    gg.searchNumber("h 3A 38 30 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺")
      ssc_method4 = true
    end
  end
  if ssc_method4 then
    limit = true
    gg.searchNumber("h 7B A 9 9 22 69 6E 62 6F 75 6E 64 73 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺")
      ssc_method5 = true
    end
  end

  if ssc_method5 then
    limit = true
    gg.searchNumber("h 7B 0A 20 20 22 64 6E 73 22 3A 20 7B 0A 20 20 20 20 22 68 6F 73 74 73 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺")
      ssc_method6 = true
    end
  end
  if ssc_method6 then
    limit = false
    gg.searchNumber("h 3A 35 33 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺")
      ssc_method7 = true
    end
  end
  if ssc_method7 then
    limit = false
    gg.searchNumber("h 5B 73 70 6C 69 74 50 73 69 70 68 6F 6E 5D 5B 73 70 6C 69 74 50 73 69 70 68 6F 6E 5D", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺")
      ssc_method8 = true
    end
    
    
  end
  if hc_method8 then
    print("en:")
    print("❌ All methods failed, try with a different file.\n")
    os.exit()
  end
  local r = gg.getResults(1000)
  if limit == false then
    r[1].address = r[1].address - 8192
  end
  readedMem = rwmem(r[1].address, 50000)
  save(hexdecode(readedMem))
  print("✅ Successfully!\n\nFile: /sdcard/decryptSSC.txt")
  gg.clearResults()
end
      



function SSHDEC()
limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/peler.txt", "w"):write(hexdecode(data))
    gg.toast("<!> ⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐀𝐇𝐈𝐌 ⧽ <!>")
end

gg.setRanges(gg.REGION_JAVA_HEAP)
gg.setSpeed(20.0)
gg.setVisible(false)
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("443")
    hc_method2 = true
end

if hc_method2 then
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("2082")
    hc_method3 = true
end
end
if hc_method3 then
gg.searchNumber(":2082@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("8880")
    hc_method4 = true
end
end
if hc_method4 then
gg.searchNumber(":8880@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("444")
    hc_method5 = true
end
end
if hc_method5 then
gg.searchNumber(":444@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("53")
    hc_method6 = true
end
end
if hc_method6 then
gg.searchNumber(":53@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("22")
    hc_method7 = true
end
end
if hc_method7 then
gg.searchNumber(":22@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("73")
    hc_method8 = true
end
end
if hc_method8 then
    print("SSH Not Found")
    os.exit()
end

local r = gg.getResults(1)
if limit == false then
    r[1].address = r[1].address - 100
end

readedMem = rwmem(r[1].address, 600)
save(readedMem)
gg.clearResults()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto inválido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "Não foi possível ler o conteúdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "print.txt"

    ---DONT REMOVE !!
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        ---DONT EDIT VALUE
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        
        outputFile:close()
    else
        print("")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depuração
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usuário e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
gg.alert(result, "copy")
gg.copyText(result, false)
    local sucesso, erro = arquivoSaida:write(result .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saída: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/peler.txt"
    local caminhoArquivoSaida = "hc_.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("SSH Not Encrypt 🥴")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        print("SSH Not Encyrption")
        return
    end

    ---XXXXXGENZ
    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        print("SSH Not Found ")
        return
    end

   --DONT REMOVE !!!! 
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    
    exibirEInserir(arquivoSaida, " ", saida)

    ---XXGENZ
    arquivoSaida:close()
end

processarSSHx()
end

function HTTPCustom()
  limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_ANONYMOUS)
gg.setVisible(false)
gg.setSpeed(20.0)
gg.searchNumber(":[host]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then   
    hc_method2 = true
end
if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(':[splitPsiphon', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method10 = true
end


end
if hc_method10 then
gg.alert("KEYWORD NOT FOUND")
os.exit()
end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto inválido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "Não foi possível ler o conteúdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/decrypt.txt"

    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saída")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)

    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usuário e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saída: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end


local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    exibirEInserir(arquivoSaida, " ", saida)
    
    arquivoSaida:close()
end    

processarSSHx()

function payloadSF()
function payload()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function payloadx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
        end
    end

    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    payloadx()
end

payload()
end

payloadSF()

function ovpnSF()
function ovpn()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function ovpnx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    ovpnx()
end

ovpn()
end

ovpnSF()

function v2raySF()
function v2ray()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

   
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] 𝐕𝟐𝐑𝐚𝐲"

    
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    v2rayx()
end

v2ray()
end

v2raySF()

local mode = {
"SSH ➔ Payload & V2ray",
"V2ray",
"SSH ➔ Payload",
"SSL ➔ SSH ➔ Direct",
"OpenVPN ➔ Payload",
"Payload ➔ OpenVPN",
"OpenVPN",
"V2ray ➔ Payload",
"SSH ➔ Direct",
"SSH ➔ Payload",
"Psiphon ➔ Payload",
"Payload",
}
local active_mode = ""
if pas and teste and proxy and testeddd then
active_mode = mode[1]
elseif testeddd then
active_mode = mode[2]
elseif host and teste then
active_mode = mode[3]
elseif sni and pas then
active_mode = mode[4]
elseif testedd then
active_mode = mode[5]
elseif teste and proxy and testedd then
active_mode = mode[6]
elseif testedd then
active_mode = mode[7]
elseif testeddd and teste then
active_mode = mode[8]
elseif pas then
active_mode = mode[9]
elseif SSH then
active_mode = mode[10]
elseif psiph and teste then
active_mode = mode[11]
elseif teste and proxy then
active_mode = mode[12]
else
active_mode = "";
end

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "*."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")
local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.") 
local psiph = string.match(content, '[%S]+FRONTED')
local psi = string.match(content, '%FRONTED.-[%w]+[%S][%w]+') 
local server = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 
local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"
local sni = string.match(content, "[%w%.-]+:%d%d+[^ ]-\0([%w%.-]-%.[%w.-]-)\0") 
local versi = string.match(content, "645") or "645"
local xX = os.date("%d/%m/%Y %I:%M:%S")

local result = {
    [1] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐇𝐨𝐬𝐭 : ",
    ['DATA'] = host
    },
    [2] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐏𝐨𝐫𝐭 : ",
    ['DATA'] = port
    },
    [3] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐔𝐬𝐞𝐫 : ",
    ['DATA'] = hostt
    },
    [4] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐏𝐚𝐬𝐬 : ",
    ['DATA'] = pas
    },
    [5] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐏𝐚𝐲𝐥𝐨𝐚𝐝 : ",
    ['DATA'] = teste
    },
    [6] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐏𝐫𝐨𝐱𝐲 : ",
    ['DATA'] = proxy
    },
	[7] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐎𝐩𝐞𝐧𝐕𝐏𝐍 : ",
    ['DATA'] = testedd
    },
    [8] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐒𝐒𝐇 : ",
    ['DATA'] = SSH
    },
    [9] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐒𝐒𝐋 : ",
    ['DATA'] = sni
    },
    [10] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐕𝟐𝐫𝐚𝐲 : ",
    ['DATA'] = testeddd
    },
    [11] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐏𝐬𝐢𝐩𝐡𝐨𝐧 𝐀𝐮𝐭𝐡𝐨𝐫𝐢𝐳𝐚𝐭𝐢𝐨𝐧",
    ['DATA'] = psiph
    },
    [12] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐏𝐬𝐢𝐩𝐡𝐨𝐧 𝐏𝐫𝐨𝐭𝐨𝐜𝐨𝐥",
    ['DATA'] = psi
    },
--    [13] = {
--    ['NAME'] = "├──────────────────────\n│[❖] 𝐕𝐞𝐫𝐬𝐢𝐨𝐧 : ",
--    ['DATA'] = versi
--    },
    [13] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝐓𝐢𝐦𝐞 : ",
    ['DATA'] = xX
    },
--    [15] = {
--    ['NAME'] = "├──────────────────────\n│[❖] 𝐓𝐮𝐧𝐧𝐞𝐥 𝐓𝐲𝐩𝐞 :",
--    ['DATA'] = active_mode
--    },
 
  }
  
      local message = "```makefile\n┌─[' @Shahriar_X_Fahim '] \n┊'⧼ 𝒮𝒽𝒶𝒽𝓇𝒾𝓇_𝒳_ℱ𝒶𝒽𝒾𝓂 ⧽'\n│'⧼ HTTP CUSTOM ⧽'\n├───╼[' t.me/Decrypt_VPN_Files ']\n└──────────────────────\n┌──────────────────────\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..""..names.."  ' "..value.." ' \n"
           end
            end
        
            message = message.."└──────────────────────\n┌──────────────────────\n│[❖] 𝐃𝐞𝐜 𝐁𝐲 :' @Shahriar_X_Fahim '\n└──────────────────────\n```"
        local alert = gg.alert(message, "𝐂𝐎𝐏𝐘", "𝐄𝐗𝐈𝐓")
        if alert == 1 then
        gg.copyText(message, false)

        elseif alert == 2 then
        end
      io.open('/sdcard/hc.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  os.exit()
  end

-- ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
function Fahim()
  limit = false
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for _FORV_5_ = 1, SizeOrBuffer do
            _rw[_FORV_5_] = {
              address = Address - 1 + _FORV_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for _FORV_5_, _FORV_6_ in ipairs(gg.getValues(_rw)) do
            if _FORV_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", _FORV_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
  end
  
  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end
  
  function hexencode(str)
    return (str:gsub(".", function(char)
      return string.format("%2x", char:byte())
    end
    ))
  end
  
  function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
  end
  
  function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
  end
  
  function save(data)
    local function hexencode_spasi(str)
      return (str:gsub(".", function(char)
          return string.format("%02x ", char:byte())
      end))
    end

    local function checkMatch(key, str)
      result = nil
      
      for index, value in ipairs(key) do
          result = str:match(value)
          if result then 
              break 
          end
      end
      
      return result
    end

    local function strip(s)
      return (s:gsub("^%s*(.-)%s*$", "%1"))
    end

    local function prosesData(data)

      local function findExpDate(tbl)
          local key = {
              "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d",
              "lifeTime"
          } 
          local result = nil
          
          for index_tbl, value_tbl in ipairs(tbl) do
  
              for index_key, value_key in ipairs(key) do
                  
                  if value_tbl:match(value_key) then
                      result = index_tbl
                  end
  
              end
          end
          return result
      end
  
      local function splitString(str, separator)
          local match_1, match_2 = str:match("(.-)"..separator.."(.*)")
          local tbl = {}
  
          no = 1
          while (match_2:match("(.-)"..separator.."(.*)") and no < 100) do
      
              match_1, match_2 = match_2:match("(.-)"..separator.."(.*)")
      
              if hexdecode(match_1):match("[^\x20]+") then
                  table.insert(tbl, strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
              else 
                  table.insert(tbl,"***")
              end
              
              no = no + 1
          end
  
          return tbl
      end
  
      local function fixedConfig(index, tbl)
          local result_fixedConfig = {}
          local beginIndex = index - 4
          local lastIndex = beginIndex + 31
  
          for i = beginIndex, lastIndex do
              table.insert(result_fixedConfig, tbl[i])
          end
  
          return result_fixedConfig
      end
      data = hexencode_spasi(data)
      data = data:gsub("00", "20")
      data = data:gsub("20", "z")
      data = data:gsub("66 61 6c 73 65", "F A L S E")
      data = data:gsub("\x20", "")
      data = data:gsub("\n", "")
      local separator = data:match("FALSE[\x7a]+(.-)[\x7a]+")
      if separator then
      data = data:gsub(separator, "0a56616c647947616e74656e67")
      separator = "0a56616c647947616e74656e67"
      end
      data = data:gsub("z", "20")
      data = data:gsub("FALSE", "66616c7365")

      local result = splitString(data, separator)
      local assemblyPointIndex = findExpDate(result)
      local getConfig = fixedConfig(assemblyPointIndex, result)
  
      return getConfig
    end
    local function getOutput(tbl)
      local cfgRegex = {
        [25] = {
            ["name"] = '[Psiphon]  : ', 
            ["regex"] = "(.*)"
        },
        [33] = {
          ["name"] = '[Psiphon]  : ',
          ["regex"]= "[\x5b]\x22.*]"
        }
 --  
    }
        
                  local message = "✯ HTTP CUSTOM\n━━━━━━━━━━━━━━━━━━━━━━\n"
               
      for index, value in ipairs(tbl) do
          
          if cfgRegex[index] and value:match(cfgRegex[index]["regex"]) then
              local namaKonten = cfgRegex[index]["name"]
              local valueRegexKonten = value:match(cfgRegex[index]["regex"])
              message = message..namaKonten.."`"..valueRegexKonten..'`'.."\n━━━━━━━━━━━━━━━━━━━━━━\n"
          end
          
      end
     message = message.."\n◇━━━━━━━━━━━━━━━━━◇\nDec By ➔ @Shahriar_X_Fahim \nGroup ➔ t.me/Decrypt_VPN_Files "
      return message
    end
 


    local contentToDecrypt = hexdecode(data)
        contentToDecrypt = prosesData(hexdecode(data))
        local hasil = getOutput(contentToDecrypt)
        io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
        gg.alert(hasil)
        io.open(gg.EXT_STORAGE .. "/psiphon.txt", "w"):write(hasil)
        gg.copyText(hasil, false)
        gg.toast("✓ Success Copy To Clipboard..!!", true)
    end
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setSpeed(20.0)
  gg.searchNumber(":GET / HTTP/", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("Method GET")
    hc_method2 = true
  end
  if hc_method2 then
    gg.searchNumber("Host: ", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("Host:")
      hc_method3 = true
    end
  end
  if hc_method3 then
    gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("inbounds")
      hc_method4 = true
    end
  end
  if hc_method4 then
    gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("[crlf]")
      hc_method5 = true
    end
  end
  if hc_method5 then
    gg.searchNumber("Upgrade: websocket", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("Upgrade: websocket")
      hc_method6 = true
    end
  end
  if hc_method6 then
    gg.searchNumber(":GET wss:", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("GET wss")
      hc_method7 = true
    end
  end
  if hc_method7 then
    gg.searchNumber(":[splitPsiphon][splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("splitPsiphon")
      hc_method8 = true
    end
  end
    if hc_method8 then
    gg.searchNumber(":[splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("[ey")
      hc_method9 = true
    end
  end
  if hc_method9 then
    gg.searchNumber(":b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("splitPsiphon")
      hc_method10 = true
    end
  end
 if hc_10 then
    limit = false
    gg.searchNumber("h 23 20 43 6F 6E 66 69 67 20 66 6F 72 20 4F 70 65 6E 56 50 4E 20 32 2E 78", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("config for OpenVPN 2x")
      hc_11 = true
    end
  end

  if hc_method11 then
    print("All methods failed")
    print('Hubungi Nathan!')
    os.exit()
  end
  local r = gg.getResults(12)
  if limit == false then
    r[1].address = r[1].address - 5376
  end
  readedMem = rwmem(r[1].address, 15000)
  save(readedMem)
  gg.clearResults()
  os.exit()
end

function UDPNEW()
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/udp.txt", "w"):write(hexdecode(data))
    
    gg.toast("Found ✅")
end

 gg.clearResults()
  gg.setRanges(gg.REGION_ANONYMOUS)
  gg.setSpeed(20.0)
  gg.setVisible(false)
 gg.searchNumber(':{"configType":', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0) 
  local r = gg.getResults(1)
  if #r < 1 then
    
    hc_2 = true
    end 
   if hc_2 then
     gg.searchNumber("h 22 55 73 65 72", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      hc_3 = true
    end
  end
  if hc_3 then
     gg.searchNumber("h 22 73 65 72 76 65 72 22 3A 20 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      hc_4 = true
    end
  end
      
  if hc_4 then
local readedMem = ""
local continue, udpcheck = true, true
if #r < 1 then
udpcheck = false
gg.toast("𝐒𝐮𝐩𝐞𝐫 𝐅𝐚𝐬𝐭 𝐏𝐫𝐞𝐦𝐢𝐮𝐦 𝐋𝐮𝐚 𝐒𝐜𝐫𝐢𝐩𝐭\n 𝐁𝐲 —͟͞͞⛦𓆩𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺𓆪メ")
HTTPCustom()
if res == 2 then
continue = false
os.exit()
end
end
  end

local r = gg.getResults(1)
  if limit == false then
    r[1].address = r[1].address - 100
  end
  readedMem = rwmem(r[1].address, 900)
  save(readedMem)
  gg.clearResults()
  
function udpSF()
function udp()

    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find('"' .. palavraChave .. '"')

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim
                
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local textoCapturado = conteudo:sub(inicioJSON, fimJSON)

               
                gg.alert(label .. ": " .. textoCapturado)
                gg.copyText(textoCapturado, false)
                local arquivoSaida = io.open("/sdcard/udp.txt", "a")

                if not arquivoSaida then
                    print("")
                    return
                end

                arquivoSaida:write(label .. ": " .. textoCapturado .. "\n\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    local function obterEntradaSSH()
        local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})

        if texto == nil then
            os.exit()
        end

        return texto[1]
    end

    local function salvarTextoEmArquivo(texto, caminhoArquivo)
        if texto == nil or texto == "" then
            return nil, "Texto inválido"
        end

        if caminhoArquivo == nil or caminhoArquivo == "" then
            return nil, "Caminho de arquivo inválido"
        end

        local arquivo = io.open(caminhoArquivo, "w")
        if arquivo == nil then
            return nil, "Não foi possível abrir o arquivo"
        end

        arquivo:write(texto)
        arquivo:close()

        return true
    end

    local function lerTextoDeArquivo(caminhoArquivo)
        if caminhoArquivo == nil or caminhoArquivo == "" then
            return nil, "Caminho de arquivo inválido"
        end

        local arquivo = io.open(caminhoArquivo, "r")
        if arquivo == nil then
            return nil, "Não foi possível abrir o arquivo"
        end

        local conteudo = arquivo:read("*all")
        arquivo:close()

        if conteudo == nil then
            return nil, "Não foi possível ler o conteúdo do arquivo"
        end

        return conteudo
    end

    local function exibirEInserir(arquivoSaida, label, texto)
        
        local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

        if not sucesso then
            print("Erro ao escrever no arquivo de saída: " .. erro)
        end
    end
        
    function udpxx()
        local caminhoArquivoEntrada = "/sdcard/udp.txt"
        local caminhoArquivoSaida = "/sdcard/udp.txt"

        local arquivoEntrada = io.open(caminhoArquivoEntrada, "r")

        if not arquivoEntrada then
            print("Falha ao abrir o arquivo de entrada: " .. caminhoArquivoEntrada)
            return 
        end

        local conteudoEntrada = arquivoEntrada:read("*all")
        arquivoEntrada:close()

        if conteudoEntrada and conteudoEntrada ~= "" then
            local hcRegex = {}
            hcRegex["Udp"] = '"user"%s*:%s*"([^"]+)"%s*,%s*"auth"%s*:%s*"([^"]+)"'

            function bitwise(val1, val2)
                return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
            end

            function extract(data, iv)
                if type(data) ~= "string" then
                    return nil, nil
                end

                local new_data = ""
                for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
                    local ivNum = tonumber(iv)
                    if not ivNum then
                        return nil, nil
                    end

                    local val1Num = tonumber(val1)
                    local val2Num = tonumber(val2)

                    if not val1Num or not val2Num then
                        return nil, nil
                    end

                    local val11 = val1Num - ivNum
                    local val22 = val2Num - ivNum

                    local val3 = ((val11 // (2 ^ val22)) % 256)
                    local car = string.char(val3)
                    new_data = new_data .. car
                end

                if verificaString(new_data) then
                    return new_data
                else
                    new_data = ""
                    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
                        car = bitwise(val1, val2)
                        new_data = new_data .. car
                    end
                    return new_data
                end
            end

            function verificaString(str)
                for i = 1, #str do
                    local char = str:sub(i, i)
                    local ascii = string.byte(char)
                    if (ascii < 32 or ascii > 126) or (ascii > 90 and ascii < 97) then
                        return false
                    end
                end
                return true
            end

            function calculaIv(user, senha)
                if type(user) ~= "string" or type(senha) ~= "string" then
                    return nil, "Usuário e senha devem ser strings"
                end

                local countU = 0
                local countP = 0
                for match in user:gmatch("(-?%d+)%.(-?%d+)") do
                    countU = countU + 1
                end
                for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
                    countP = countP + 1
                end

                return countU, countP
            end

            function dec_user_pass(user, userIv, pasw, passIv)
                return extract(user, userIv), extract(pasw, passIv)
            end

            local udpUserEnc, udpPassEnc = string.match(conteudoEntrada, hcRegex["Udp"])

            if udpUserEnc and udpPassEnc then
                local userIv, passIv = calculaIv(udpUserEnc, udpPassEnc)

                if userIv and passIv then
                    local udpUser, udpPass = dec_user_pass(udpUserEnc, userIv, udpPassEnc, passIv)

                    if udpUser and udpPass then
                        
                        local resultadoDecodificado = "Username: " .. udpUser .. "\nPassword: " .. udpPass
                        conteudoEntrada = string.gsub(conteudoEntrada, 'user": "([%d-.]+)"', 'user": "' .. udpUser .. '"')
                        conteudoEntrada = string.gsub(conteudoEntrada, 'auth": "([%d-.]+)"', 'auth": "' .. udpPass .. '"')

                        conteudoEntrada = removeNullBytes(conteudoEntrada)

                        local arquivoSaida = io.open(caminhoArquivoSaida, "w")
                        
                        if not arquivoSaida then
                            
                        else
                            arquivoSaida:write(conteudoEntrada)
                            arquivoSaida:close()
                   
                        end
                    else
                        
                    end
                else
                    
                end
            else
                print("")

            end
        end
    end

    
    udpxx()
end

udp()
end

udpSF()

local f = io.open("/sdcard/udp.txt", "r")
local content = f:read("*all")
f:close()

local f = io.open("/sdcard/udp.txt", "w")
f:write(content)
f:close()

local start = "```makefile\n┌─[' @Shahriar_X_Fahim '] \n┊'⧼ 𝒮𝒽𝒶𝒽𝓇𝒾𝓇_𝒳_ℱ𝒶𝒽𝒾𝓂 ⧽'\n│⧼ 𝐔𝐃𝐏 𝐂𝐔𝐒𝐓𝐎𝐌 ⧽\n├───╼[' t.me/Decrypt_VPN_Files ']\n└──────────────────────\n"
local final = ""

content = string.gsub(content, '"server": "', '",    "server": "')

local app = content:match('udp') or 'udp'
local server_udp = content:match('"server": "(.-)"')
local user_udp = content:match('"user": "(.-)"')
local auth_udp = content:match('"auth": "(%w+)"')
local sni_udp = content:match('"sni": "(.-)"')
local rx_udp = content:match('"rx_receive": (%d+)')
local tx_udp = content:match('"tx_transfer": (%d+)')
local stream_udp = content:match('"stream_buffer": (%d+)')
local receive_udp = content:match('"receive_buffer": (%d+)')
local insicure_udp = content:match('"insecure": (%w+)')
local socks_udp = content:match('"socks5": (%d+)') or "{"
local listen_udp = content:match('"listen": "(.-)"')

local message = start

local function addKey(label, value)
  if value and value ~= "" then
    message = message .. '' .. label .. '' .. value .. '\n'
  end
end

addKey("┌──────────────────────\n│[❖] 𝐒𝐧𝐢: ", sni_udp)
addKey("├──────────────────────\n│[❖] 𝐑𝐱_𝐫𝐞𝐜𝐞𝐢𝐯𝐞: ", rx_udp)
addKey("├──────────────────────\n│[❖] 𝐓𝐱_𝐭𝐫𝐚𝐧𝐬𝐟𝐞𝐫: ", tx_udp)
addKey("├──────────────────────\n│[❖] 𝐒𝐭𝐫𝐞𝐚𝐦_𝐛𝐮𝐟𝐟𝐞𝐫: ", stream_udp)
addKey("├──────────────────────\n│[❖] 𝐑𝐞𝐜𝐞𝐢𝐯𝐞_𝐛𝐮𝐟𝐟𝐞𝐫: ", receive_udp)
addKey("├──────────────────────\n│[❖] 𝐋𝐢𝐬𝐭𝐞𝐧: ", listen_udp)
addKey("├──────────────────────\n│[❖] 𝐀𝐮𝐭𝐡: ' ", server_udp ..'@'.. user_udp ..':'.. auth_udp .."'\n└──────────────────────\n┌──────────────────────\n│[❖] 𝐃𝐞𝐜 𝐁𝐲 : @Shahriar_X_Fahim\n└──────────────────────\n```")

if message ~= "" then
  message = message .. final
  gg.alert(message, '𝐂𝐎𝐏𝐘 𝐔𝐃𝐏')
  gg.copyText(message, false)
end

local f = io.open("/sdcard/udp.txt", "w")
f:write(message)

f:close()
gg.setVisible(false)
end
  
function V2RAY()

limit = false
function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  
  if type(SizeOrBuffer) == "number" then
    _ = ""
    
    for SRD1_5_ = 1, SizeOrBuffer do
      _rw[SRD1_5_] = {
        address = Address - 1 + SRD1_5_,
        flags = gg.TYPE_BYTE
      }
    end
    
    for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
      if SRD1_6_.value == 0 and limit == true then
        return _
      end
      
      _ = _ .. string.format("%02X", SRD1_6_.value & 255)
    end
    
    return _
  end
  
  Byte = {}
  SizeOrBuffer = SizeOrBuffer:gsub("[^%w%s%p]+", "")
  
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end)
  
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
  io.open("/sdcard/e-V2ray.txt", "w"):write(data)
end

limit = true
gg.setVisible(false)
gg.processPause()
gg.clearResults()
gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_PPSSPP | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_BAD)
  gg.setSpeed(20.0)
  gg.setVisible(false)
  gg.searchNumber("h 7B 0A 09 09 22 69 6E 62 6F 75 6E 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("inbounds")
    hc_2 = true
  end
  if hc_2 then 
    gg.searchNumber("h 7B 0A 09 09 22 64 6E 73 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_3 = true
    end
  end
  if hc_3 then
    gg.searchNumber("h 20 22 64 6e 73 22 3a 20 7b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_4 = true
    end
  end
  if hc_4 then
    gg.searchNumber("h 7B 0A 09 09 09 09 09 09 09 09 09 09 09 09 22 61 64 64 72 65 73 73 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("address")
      hc_5 = true
    end
  end
  if hc_5 then
    gg.searchNumber("h 22 6c 6f 67 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_6 = true
    end
  end
  if hc_6 then
    gg.searchNumber("h 22 6f 75 74 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("outbounds")
      hc_7 = true
    end
  end
  
  
  
  if hc_7 then
gg.searchNumber("h 22 69 6e 62 6f 75 6e 64 73 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_8 = true
    end
  end  
  
   if hc_8 then
gg.searchNumber("h 22 64 6e 73 22 3a 20", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_9 = true
    end
  end 
  
    if hc_9 then
gg.searchNumber("h 22 64 6e 73 22 3a 20", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_10 = true
    end
  end  
    if hc_10 then
gg.searchNumber("h 22 69 6e 62 6f 75 6e 64 73 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_11 = true
    end
  end    
  if hc_11 then
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_12 = true
    end
  end      
  if hc_12 then
gg.searchNumber(':{\n		"dns":', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_13 = true
    end
  end       
  
   
    
     
       
  
  
  
      if hc_13 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
    print("all metode Failed\n")
    os.exit()        
        
    end
    if hc_13 then
    gg.alert("Decryption failed use Clear/Reset Config and reimport the file")
    gg.processResume()
    gg.toast("  𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐅𝐚𝐢𝐥𝐞𝐝!  ")
    print("DONE")
   os.exit()
  end
  local r = gg.getResults(4)
    if limit == false then
        r[1].address = r[1].address - 200
        end
    
    readedMem = rwmem(r[1].address, 5000)
  save(hexdecode(readedMem))
  gg.processResume()
  gg.clearResults()

local f = io.open("/sdcard/e-V2ray.txt", "r")
local content = f:read("*all")
f:close()

content = "```json\n┌─────────────────\n│ [ム] 𝗩𝟮𝗥𝗔𝗬 𝗔𝗟𝗟 𝗝𝗦𝗢𝗡 ▼\n├─────────────────\n│ [ム] 𝗖𝗢𝗗𝗘 𝗕𝗬: t.me/Decrypt_VPN_Files\n├─────────────────\n`" .. content .. "`\n├─────────────────\n│ [ム] 𝗗𝗲𝗰𝗿𝘆𝗽𝘁 𝗕𝘆: @Shahriar_X_Fahim\n└─────────────────\n```"

local f = io.open("/sdcard/e-V2ray.txt", "w")
f:write(content)
f:close()
gg.alert(content, 'COPY AND EXIT')
gg.copyText(content, false)
gg.toast("⎙  𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐒𝐮𝐜𝐜𝐞𝐬𝐬!  ⎙")
print(" DONE ")
end


function SSCCustom()
  limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_ANONYMOUS)
gg.setVisible(false)
gg.setSpeed(20.0)
gg.searchNumber(":[host]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then   
    hc_method2 = true
end
if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(':[splitPsiphon', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method10 = true
end
end
if hc_method10 then
gg.alert("KEYWORD NOT FOUND")
os.exit()
end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto inválido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "Não foi possível ler o conteúdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/decrypt.txt"

    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saída")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)

    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usuário e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saída: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end


local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    exibirEInserir(arquivoSaida, " ", saida)
    
    arquivoSaida:close()
end    

processarSSHx()

function payloadSF()
function payload()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function payloadx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
        end
    end

    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    payloadx()
end

payload()
end

payloadSF()

function ovpnSF()
function ovpn()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function ovpnx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end


  local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    ovpnx()
end

ovpn()
end

ovpnSF()

function v2raySF()
function v2ray()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

   
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] 𝐕𝟐𝐑𝐚𝐲"

    
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    v2rayx()
end

v2ray()
end

v2raySF()

local mode = {
"SSH ➔ Payload & V2ray",
"V2ray",
"SSH ➔ Payload",
"SSL ➔ SSH ➔ Direct",
"OpenVPN ➔ Payload",
"Payload ➔ OpenVPN",
"OpenVPN",
"V2ray ➔ Payload",
"SSH ➔ Direct",
"SSH ➔ Payload",
"Psiphon ➔ Payload",
"Payload",
}
local active_mode = ""
if pas and teste and proxy and testeddd then
active_mode = mode[1]
elseif testeddd then
active_mode = mode[2]
elseif host and teste then
active_mode = mode[3]
elseif sni and pas then
active_mode = mode[4]
elseif testedd then
active_mode = mode[5]
elseif teste and proxy and testedd then
active_mode = mode[6]
elseif testedd then
active_mode = mode[7]
elseif testeddd and teste then
active_mode = mode[8]
elseif pas then
active_mode = mode[9]
elseif SSH then
active_mode = mode[10]
elseif psiph and teste then
active_mode = mode[11]
elseif teste and proxy then
active_mode = mode[12]
else
active_mode = "";
end

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "*."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")
local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.") 
local psiph = string.match(content, '[%S]+FRONTED')
local psi = string.match(content, '%FRONTED.-[%w]+[%S][%w]+') 
local server = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 
local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"
local sni = string.match(content, "[%w%.-]+:%d%d+[^ ]-\0([%w%.-]-%.[%w.-]-)\0") 
local versi = string.match(content, "645") or "645"
local xX = os.date("%d/%m/%Y %I:%M:%S")

local result = {
   [1] = {
   ['NAME'] = "├──────────────────────\n┃[❖] 𝙎𝙎𝙃 𝘼𝙙𝙙𝙧𝙚𝙨𝙨 : ",
    ['DATA'] = host
    },
    [2] = {
    ['NAME'] = "├──────────────────────\n┃[❖] 𝙋𝙤𝙧𝙩 : ",
    ['DATA'] = port
    },
    [3] = {
    ['NAME'] = "├──────────────────────\n┃[❖] 𝙐𝙨𝙚𝙧𝙣𝙖𝙢𝙚 : ",
    ['DATA'] = hostt
    },
    [4] = {
    ['NAME'] = "├──────────────────────\n┃[❖] 𝙋𝙖𝙨𝙨𝙬𝙤𝙧𝙙 : ",
    ['DATA'] = pas
    },
    [5] = {
    ['NAME'] = "┌──────────────────────\n│[❖] 𝙋𝙖𝙮𝙡𝙤𝙖𝙙 : ",
    ['DATA'] = teste
    },
    [6] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝙋𝙧𝙤𝙭𝙮 : ",
    ['DATA'] = proxy
    },
  	[7] = {
    ['NAME'] = "├──────────────────────\n┃[❖] 𝙊𝙑𝙋𝙉 : ",
    ['DATA'] = testedd
    },
    [8] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝙎𝙎𝙃 : ",
    ['DATA'] = SSH
    },
    [9] = {
    ['NAME'] = "├──────────────────────\n│[❖] 𝙎𝙎𝙇/𝙎𝙉𝙄 : ",
    ['DATA'] = sni
    },
    [10] = {
    ['NAME'] = "├──────────────────────\n┃[❖] 𝙑2𝙍𝘼𝙔 : ",
    ['DATA'] = testeddd
    },
    [11] = {
    ['NAME'] = "├──────────────────────\n┃[❖] 𝙋𝙨𝙞𝙥𝙝𝙤𝙣 𝘼𝙪𝙩𝙝",
    ['DATA'] = psiph
    },
    [12] = {
    ['NAME'] = "├──────────────────────\n┃[❖] 𝙋𝙨𝙞𝙥𝙝𝙤𝙣 𝙋𝙧𝙤𝙩𝙤𝙘𝙤𝙡",
    ['DATA'] = psi
    },
--    [13] = {
--    ['NAME'] = "├──────────────────────\n┃[❖] 𝘼𝙥𝙥 𝙑𝙚𝙧𝙨𝙞𝙤𝙣 : ",
--    ['DATA'] = versi
--    },
--    [14] = {
--    ['NAME'] = "├──────────────────────\n┃[❖] 𝙏𝙄𝙈𝙀 : ",
--    ['DATA'] = xX
--    },
--    [15] = {
--    ['NAME'] = "├──────────────────────\n┃[❖] 𝙏𝙪𝙣𝙣𝙚𝙡 𝙏𝙮𝙥𝙚 :",
--    ['DATA'] = active_mode
--    },
 
  }
  
      local message = "```makefile\n┌─[ @Shahriar_X_Fahim ] \n┊⧼ 𝒮𝒽𝒶𝒽𝓇𝒾𝓇_𝒳_ℱ𝒶𝒽𝒾𝓂 ⧽\n│⧼ SSC CUSTOM ⧽\n├───╼[ t.me/Decrypt_VPN_Files ]\n└──────────────────────\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..""..names.."  ' "..value.." ' \n"
           end
            end
        
            message = message.."└──────────────────────\n┌──────────────────────\n│[❖] 𝘿𝙚𝙘 𝘽𝙮 : @Shahriar_X_Fahim\n└──────────────────────\n```"
        local alert = gg.alert(message, "𝘾𝙊𝙋𝙔", "𝘾𝘼𝙉𝘾𝙀𝙇")
        if alert == 1 then
        gg.copyText(message, false)

        elseif alert == 2 then
        end
      io.open('/sdcard/hc.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  os.exit()
  end

function NpvtSSH()
limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
--ProgressBar = "鈺戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈺?";for x = 1,15,1 do gg.sleep(40) ---ProgressBar = ProgressBar:gsub("鈻?","鈻?",1);gg.toast(ProgressBar) end
    io.open(gg.EXT_STORAGE .. "/HTTP_CUSTOM.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP)
gg.setSpeed(20.0)
---gg.makeRequest("https://raw.githubusercontent.com/EstebanZxx/Forbidden/main/KEY-ACCESS") key= W4nn4P14yW1thKyy 🐸🐸
gg.setVisible(false)
--gg.setVisible(false)
gg.searchNumber(":[lf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method2 = true
end

if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(":444@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method10 = true
end
end
if hc_method10 then
    gg.alert("No matching keywords!")
    os.exit()
end

local r = gg.getResults(100)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/HTTP_CUSTOM.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/HTTP_CUSTOM.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto inv谩lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inv谩lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "N茫o foi poss铆vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inv谩lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "N茫o foi poss铆vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "N茫o foi poss铆vel ler o conte煤do do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/HTTP_CUSTOM.txt"

    -- Abre o arquivo no modo de escrita no diret贸rio do script
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        -- Construir a string com os valores a serem salvos
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de sa铆da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depura莽茫o
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usu谩rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de sa铆da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt"
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    -- Criar ou abrir o arquivo de sa铆da
    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end

    -- Concatenar os resultados
local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
sshResults = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    -- Exibir e salvar os resultados
    exibirEInserir(arquivoSaida, " ", saida)
    
-- Fechar o arquivo de sa铆da
    arquivoSaida:close()
end    

processarSSHx()

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "***."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")

local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.")

function payloadx9()
function payload()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end
    
    
        local function payloadx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
    ---        teste = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    payloadx()
end

payload()
end

payloadx9()

function ovpnx9()
function ovpn()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function ovpnx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
---        testedd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    ovpnx()
end

ovpn()
end

ovpnx9()

function v2rayx9()
function v2ray()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()
                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function v2rayx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] 饾悤饾煇饾悜饾悮饾惒"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
 ---       testeddd= "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    v2rayx()
end

v2ray()
end

v2rayx9()

function pythonx9()
function python()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedddd = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function pythonx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsPython = {'"ey', 'FRONTED-'}
    local labelPython = ""

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouPython = tentarEncontrarPalavrasChave(conteudo, keywordsPython, labelPython)

    if encontrouPython then
        print("")
    else
  --     testedddd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    pythonx()
end

python()
end

pythonx9()

local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 

local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"

local sni = string.match(content, "[%w%.-]+:%d%d+[^馃槇]-\0([%w%.-]-%.[%w.-]-)\0") 

local ns  = string.match(content, "false") or "false"

local pubkey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65][%w.-]+.") 

local psiphon = string.match(content, "[\x5b]\x22.*]") or false

local versi = string.match(content, "645") or "645"

local xX = os.date("%d/%m/%Y %I:%M:%S")

--local xX = os.date("%I:%M %p")

function keyx9()
function key()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                pub = (texto) 
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function keyx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"b22", "bc2c"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
     ---       pub = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    keyx()
end

key()
end

keyx9()

function slowdnsx9()
function slowdns()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                name = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function slowdnsx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsSlowdns = {"ns", "n%s-"}
        local labelSlowdns = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouSlowdns = tentarEncontrarPalavrasChave(conteudo, keywordsSlowdns, labelSlowdns)

        if encontrouSlowdns then
            print("")
        else
        --    name = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    slowdnsx()
end

slowdns()
end

slowdnsx9()
local SlowDnsServer = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local PubKey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65]+")
local SSLSNI = string.match(content, "[%w]-%.[%w]-%.[%w]-")

local result = {
    [1] = {
    ['NAME'] = "\n│[ム] 𝐉𝐬𝐨𝐧 𝐅𝐨𝐫𝐦𝐚𝐭𝐞 : ",
    ['DATA'] = teste
    },
   	[2] = {
    ['NAME'] = "\n│[ム] 𝐏𝐫𝐨𝐱𝐲 : ",
    ['DATA'] = proxy
    },
--    [3] = {
--    ['NAME'] = "\n│[ム] 𝐒𝐒𝐇 : ",
--    ['DATA'] = sshResults
--    },
    [3] = {
    ['NAME'] = "\n│[ム] 𝐒𝐒𝐋 : ",
    ['DATA'] = SSLSNI
    },
--    [5] = {
--    ['NAME'] = "\n│[ム] 𝐕2𝐑𝐀𝐘 : ",
--    ['DATA'] = testeddd
--    },
--    [6] = {
--    ['NAME'] = "\n│[ム] 𝐏𝐒𝐈𝐏𝐇𝐎𝐍 : ",
--    ['DATA'] = testedddd
--    },
--    [7] = {
--    ['NAME'] = "\n│[ム] 𝐎𝐕𝐏𝐍 : ",
--    ['DATA'] = testedd
--    },

  }
  
      local message = "```rust\n┌────────────────────\n│[ム] 𝐂𝐨𝐝𝐞 𝐁𝐲 : @Shahriar_X_Fahim\n│[ム] 𝐆𝐫𝐨𝐮𝐩 : t.me/Decrypt_VPN_Files"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message.."\n├────────────────────"..names.." ' "..value.." ' "
           end
            end
         
            message = message.."\n├────────────────────\n│[ム] 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐁𝐲 : @Shahriar_X_Fahim\n└────────────────────\n```"
        local alert = gg.alert(message, "𝐒𝐀𝐕𝐄", "𝐂𝐀𝐍𝐂𝐄𝐋")
        if alert == 1 then
        gg.copyText(message, false)
        gg.toast("Copied To Clipboard")
        elseif alert == 2 then
        end
      io.open('/sdcard/HTTP_CUSTOM.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  end                



function sip()
gg.setVisible(true)
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for SRD1_5_ = 1, SizeOrBuffer do
            _rw[SRD1_5_] = {
              address = Address - 1 + SRD1_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
            if SRD1_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", SRD1_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
end

  

  function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
  end

  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end

  gg.clearResults()
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_PPSSPP | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_BAD)
  gg.setSpeed(20.0)
  gg.setVisible(false)
  gg.searchNumber("h 6c 69 73 74 65 6e 50 6f 72 74 71 00 7e 00 01 4c 00 06", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    
    sip_2 = true
  end
  if sip_2 then
    gg.searchNumber("h6E6577746F6F6C73776F726B732E636F6D2E736F636B7369702E7574696C732E536572536F636B73495068", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_3 = true
    end
  end
  if sip_3 then
    gg.searchNumber("h 55 70 67 72 61 64 65 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_4 = true
    end
  end
  if sip_4 then
    gg.searchNumber("h 3A 38 30 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_5 = true
    end
  end
  if sip_5 then
    limit = false
    gg.searchNumber("h 7B 0A 09 09 22 69 6E 62 6F 75 6E 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_6 = true
    end
  end
  if sip_6 then
    limit = false
    gg.searchNumber("h 73 70 65 65 64 79 73 73 68 2e", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_7 = true
    end
  end
  if sip_7 then
    limit = false
    gg.searchNumber("h 3A 35 33 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_8 = true
    end
  end
  if sip_8 then
    limit = false
    gg.searchNumber("h 47 45 54 20 77", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_9 = true
    end
  end
  if sip_9 then
    limit = false
    gg.searchNumber("h 5b 63 72 6c 66 5d 48 6f 73 74 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_10 = true
    end
  end
  if sip_10 then
    limit = false
    gg.searchNumber("h 48 6f 73 74 3a 5b 72 6f 74 61 74 65 3d", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_11 = true
    end
  end
  if sip_11 then
    limit = false
    gg.searchNumber("h 3A 34 34 33 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_12 = true
    end
  end
  if sip_12 then
    gg.toast("𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺")
    print("Close Socksip, reopen after 3secs and try again \n\n")
    os.exit()
  end
  local r = gg.getResults(9000)
  if limit == false then
    r[1].address = r[1].address - 8192
  end
  _G.readedMem = rwmem(r[1].address, 9000)
  save(hexdecode(readedMem))
  
  print("✓ Saved In: /sdcard/decrypt.txt")
  gg.clearResults()
  
  
    
  local file = io.open("/sdcard/decrypt.txt", 'rb')
  local content = file:read(9000)
  file:close()
  local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
  local sshcontent = sshfile:read(3400)
  sshfile:close()

local serverPayload = string.match(sshcontent, "GET%s.*TCP") or string.match(content, "POST%s.*TCP")or string.match(content, "CONNECT%s.*TCP")or string.match(content, "PUT%s.*TCP")or string.match(content, "BMOVE%s.*TCP") or string.match(content, "[A-Z]%sHTTP/.*TCP") or string.match(content, "HTTP/.*TCP") or string.match(content, "HTTP/.*%[lf%]") or string.match(content, "HTTP/.*%[crlf%]") or "___"
if not string.match(sshcontent, "GET%s.*TCP") or not string.match(sshcontent, "POST%s.*TCP") or not string.match(sshcontent, "CONNECT%s.*TCP") or string.match(sshcontent, "PUT%s.*TCP")then
local payload = {}
for i = 1, #serverPayload - 6 do
table.insert(payload, string.sub(serverPayload, i, i))
end
serverPayload = table.concat(payload,"")
else end

local SSH = string.match(sshcontent, "[%d%.%w.-]+:[%d]+@[%w%.-]+:[%w%.-]+")  or "_"
local shs = {}
for i = 1, #SSH - 1 do
table.insert(shs, SSH:sub(i,i))
end
SSH = table.concat(shs, "")


local udpserver = string.match(sshcontent, "%d+%.%d+%.%d+%.%d+t") or ""
udpserver = udpserver:gsub('t', "")

local websocket = string.match(content, "[%a%d]+%.[%w+%a]+%.xyzt  ") or ""
websocket = websocket:gsub("t  q ~", "")

local sshusern = string.match(content, "@[%w+%.-]+") or false

local udpuser = sshcontent:match('t %c[%w%.-]+-%w+') or string.match(sshcontent, "[%w%.-]+-%w+")  or "_"
local us = {}
for i = 1, #udpuser - 1 do
table.insert(us, udpuser:sub(i,i))
udpusern = table.concat(us, "")
udpusern = udpusern:gsub('t%c','')
udpusern = udpusern:gsub("%c","")
end
udpusern = udpusern or ""

local username2 = string.match(sshcontent, "t %w+q")  or "___"

udpass = string.match(sshcontent, "%Ct [%c%s]+%w+t [%c]%d") or sshcontent:match("zt [%c%s]+%w+t [%c]%d") or sshcontent:match("t [%c%s]+%w+t [%c]%d") or "___"
local sp1 = {}
for i = 4, #udpass -4 do
table.insert(sp1, udpass:sub(i,i))
end
local udpass = table.concat(sp1,"")
udpass = udpass:gsub("%c","")
udpass = udpass:gsub("%s","")

local suser = {}
sshusername = string.match(sshcontent, "t [%c]+%w+t  q ") or "___"
for i = 4, #sshusername - 5 do
table.insert(suser, sshusername:sub(i,i))
end
sshusername = table.concat(suser,"")
local sshusername2 = SSH:match("@([%w%-]+):") or false
local suser2 = {}
for i = 2, #sshusername - 1 do
table.insert(suser2, sshusername2:sub(i,i))
end
sshusername2 = table.concat(suser2, "")
local spass = {}
sshpassword = string.match(sshcontent, "t [%c]+%w+t") or "___"
for i = 4, #sshpassword - 1 do
table.insert(spass, sshpassword:sub(i,i))
end
sshpassword = table.concat(spass,"")

local sshproxy = string.match(sshcontent, "[%w%.]+:[%d]+t") or ""
sshproxy = sshproxy:gsub('t','')

local proxy = string.match(content, "%d+%.%d+%.%d+%.%d+:8080") or content:match('%d+%.%d+%.%d+%.%d+:80') or string.match(content, "%d+%.%d+%.%d+%.%d+:443")  or string.match(content, "%d+%.%d+%.%d+%.%d+:3128")

local nameserver = string.match(content,"n%w+%d?%.fibertunnel.xyzt") or  string.match(content, "nsam%d?[%w.-]+") or string.match(content, "n%w+%d?[%w.-]+") or "_"
local ns = {}
for i = 1, #nameserver - 1 do
table.insert(ns, nameserver:sub(i,i))
end 
local nameserver = table.concat(ns,"")

local serverLocation = string.match(content,"Amsterdam EU") or string.match(content,"France EU") or string.match(content,"USA %d")

local serverProtocol = string.match(content, "%u+,%u+,%u+,%u+")

local serverDNS = string.match(content, "%d+%.%d+%.%d+%.%d+:53") or ""

local hostws = string.match(content,"%U%U%d?%.fibertunnel.xyz") or string.match(content, "%A+%.%A+%.xyz") or string.match(content,"br1.fibertunnel.xyz") or string.match(content,"br2.fibertunnel.xyz") or string.match(content,"gr1.fibertunnel.xyz") or string.match(content,"ca1.fibertunnel.xyz") or string.match(content,"uk1.fibertunnel.xyz") or string.match(content,"uk2.fibertunnel.xyz") or string.match(content,"fr1.fibertunnel.xyz") or string.match(content,"fr2.fibertunnel.xyz") or string.match(content,"am1.fibertunnel.xyz")

local pubkey = string.match(content, "@[%d%U]+a") or ""

local pkey = string.match(pubkey, "[%d%a]+") or ""

local notes = content:match("<.*>.*</[%w%p]+>") or content:match("<[%w%p%s]+>.*</[%w%p]+>")

local sni = content:match("[%w]+%.[%w]+%.[%w]+%.[%w]+t") or content:match("[%w]+%.[%w]+%.[%w]+t") or content:match("[%w]+%.[%w]+t") or "_"
local sn = {}
for i = 1, #sni - 1 do
table.insert(sn, sni:sub(i,i))
end 
sni = table.concat(sn, "")

local key = content:match("[%w][%w%p%a]+=")

local mode = {"Request/Single Tunnel","Custom SSH","Custom UDP","DNS","Custom Websocket",}
local active_mode = ""
if #serverPayload > 10 then
active_mode = mode[1]
elseif #udpserver > 7 and #udpusern > 5 or #udpass > 6 then
active_mode = mode[3]
elseif #SSH > 7 and sshusername > 3 and sshpassword > 3 then
active_mode = mode[2]
elseif #serverDNS > 6 and  #pkey > 10 then
active_mode = mode[4]
elseif  #sni > 6 and #serverPayload < 10 and #udpserver < 6 then
active_mode = mode[5]
else
active_mode = "";
end

local result = {
	[1] = {
    ['NAME'] = "├──────────────────────\n│[✮] sock_mode",
    ['DATA'] = active_mode
  },
  [2] = {
    ['NAME'] = "├──────────────────────\n│[✮] payload",
    ['DATA'] = serverPayload
  },
  [3] = {
    ['NAME'] = "├──────────────────────\n│[✮] server_udp",
    ['DATA'] = udpserver 
  },
  [6] = {
    ['NAME'] = "├──────────────────────\n│[✮] server",
    ['DATA'] = SSH
  },
  [4] = {
    ['NAME'] = "├──────────────────────\n│[✮] username_udp",
    ['DATA'] = udpusern
  },
  [5] = {
    ['NAME'] = "├──────────────────────\n│[✮] password_udp",
    ['DATA'] = udpass
  },
    [7] = {
    ['NAME'] = "├──────────────────────\n│[✮] username",
    ['DATA'] = sshusername
  },
    [8] = {
    ['NAME'] = "├──────────────────────\n│[✮] password",
    ['DATA'] = sshpassword
  },
  [9] = {
    ['NAME'] = "├──────────────────────\n│[✮] proxy",
    ['DATA'] = sshproxy
  },
  [10] = {
    ['NAME'] = "├──────────────────────\n│[✮] proxy_port",
    ['DATA'] = proxy
  },
  [11] = {
    ['NAME'] = "├──────────────────────\n│[✮] host_websocket",
    ['DATA'] = hostws or websocket
  },
  [12] = {
    ['NAME'] = "├──────────────────────\n│[✮] location", 
    ['DATA'] = serverLocation
  },
  [13] = {
    ['NAME'] = "├──────────────────────\n│[✮] protocol", 
    ['DATA']= serverProtocol
  },
  [14] = {
    ['NAME'] = "├──────────────────────\n│[✮] ssl_sni",
     ['DATA'] = sni
    },
  [15] = {
    ['NAME'] = "├──────────────────────\n│[✮] server_dn", 
    ['DATA'] = serverDNS
  },
  [16] = {  
["NAME"] = "├──────────────────────\n│[✮] name_server",   
 ["DATA"] = nameserver
},
[17] = { 
["NAME"] = "├──────────────────────\n│[✮] public_key", 
['DATA'] = pkey
},
 [19] = { 
["NAME"] = "├──────────────────────\n│[✮] notes" , 
['DATA'] = notes
},
[18] = { 
["NAME"] = "├──────────────────────\n│[✮] server_key" , 
['DATA'] = key
},
 
  }
  
      local message = "```makefile\n┌──────────────────────\n│𝐒𝐎𝐂𝐊𝐒𝐈𝐏 (𝐒𝐈𝐏)\n│𝐆𝐫𝐨𝐮𝐩: t.me/Decrypt_VPN_Files\n├──────────────────────\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..names.." : ' "..value.." '\n"
           end
            end

            message = message.."├──────────────────────\n│𝐃𝐞𝐜 𝐁𝐲 :' t.me/Shahriar_X_Fahim '\n└──────────────────────\n```"
      gg.alert(message, "COPY TO CLIPBOARD")
      io.open('/sdcard/socksip.txt', 'w'):write(message)
      gg.copyText(message, false)
      gg.toast("𝗦𝗵𝗮𝗵𝗿𝗶𝗮𝗿 𝗙𝗮𝗵𝗶𝗺")
    save(hexdecode(readedMem))
  gg.clearResults()
end



function Npvtv2ray()
  limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_PPSSPP | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_BAD)
  gg.setVisible(false)
  gg.setSpeed(20.0)
  gg.searchNumber("h 7B 0A 09 09 22 69 6E 62 6F 75 6E 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("inbounds")
    hc_method2 = true
  end
  if hc_method2 then 
    gg.searchNumber("h 7B 0A 09 09 22 64 6E 73 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("dns")
      hc_method3 = true
    end
  end
  if hc_method3 then
    gg.searchNumber("h 20 22 64 6e 73 22 3a 20 7b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_method4 = true
    end
  end
  if hc_method4 then
    gg.searchNumber("h 7B 0A 09 09 09 09 09 09 09 09 09 09 09 09 22 61 64 64 72 65 73 73 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("address")
      hc_method5 = true
    end
  end
  if hc_method5 then
    gg.searchNumber("h 22 6c 6f 67 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("address")
      hc_method6 = true
    end
  end
  if hc_method6 then
    gg.searchNumber("h 22 6f 75 74 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("outbounds")
      hc_method7 = true
    end
  end
if hc_method7 then
    gg.searchNumber("h 22 6f 75 74 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_method8 = true
    end
  end  
  
  
  
  if hc_method8 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
    print("all metode failed\n")
    os.exit()
  end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()


function v2raySF()
function v2ray()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

   
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] 𝐕𝟐𝐑𝐚𝐲"

    
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    v2rayx()
end

v2ray()
end

v2raySF()

local mode = {
"SSH ➔ Payload & V2ray",
"V2ray",
"SSH ➔ Payload",
"SSL ➔ SSH ➔ Direct",
"OpenVPN ➔ Payload",
"Payload ➔ OpenVPN",
"OpenVPN",
"V2ray ➔ Payload",
"SSH ➔ Direct",
"SSH ➔ Payload",
"Psiphon ➔ Payload",
"Payload",
}
local active_mode = ""
if pas and teste and proxy and testeddd then
active_mode = mode[1]
elseif testeddd then
active_mode = mode[2]
elseif host and teste then
active_mode = mode[3]
elseif sni and pas then
active_mode = mode[4]
elseif testedd then
active_mode = mode[5]
elseif teste and proxy and testedd then
active_mode = mode[6]
elseif testedd then
active_mode = mode[7]
elseif testeddd and teste then
active_mode = mode[8]
elseif pas then
active_mode = mode[9]
elseif SSH then
active_mode = mode[10]
elseif psiph and teste then
active_mode = mode[11]
elseif teste and proxy then
active_mode = mode[12]
else
active_mode = "";
end


local result = {
--    [1] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐇𝐨𝐬𝐭 : ",
--    ['DATA'] = host
--    },
--    [2] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐏𝐨𝐫𝐭 : ",
--    ['DATA'] = port
--    },
--    [3] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐔𝐬𝐞𝐫 : ",
--    ['DATA'] = hostt
--    },
--    [4] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐏𝐚𝐬𝐬 : ",
--    ['DATA'] = pas
--    },
--     [1] = {
--     ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐏𝐚𝐲𝐥𝐨𝐚𝐝 : ",
--     ['DATA'] = teste
--    },
--    [6] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐏𝐫𝐨𝐱𝐲 : ",
--    ['DATA'] = proxy
--    },
--   	[7] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐎𝐩𝐞𝐧𝐕𝐏𝐍 : ",
--    ['DATA'] = testedd
--    },
--    [8] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐒𝐒𝐇 : ",
--    ['DATA'] = SSH
--    },
--    [9] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐒𝐒𝐋 : ",
--    ['DATA'] = sni
--    },
    [1] = {
    ['NAME'] = "├────────────────────\n│[❖] 𝐕2𝐫𝐚𝐲 : ",
    ['DATA'] = testeddd
    },
--    [11] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐏𝐬𝐢𝐩𝐡𝐨𝐧 𝐀𝐮𝐭𝐡𝐨𝐫𝐢𝐳𝐚𝐭𝐢𝐨𝐧",
--    ['DATA'] = psiph
--    },
--    [12] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐏𝐬𝐢𝐩𝐡𝐨𝐧 𝐏𝐫𝐨𝐭𝐨𝐜𝐨𝐥",
--    ['DATA'] = psi
--    },
--    [13] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐕𝐞𝐫𝐬𝐢𝐨𝐧 : ",
--    ['DATA'] = versi
--    },
--    [13] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐓𝐢𝐦𝐞 : ",
--    ['DATA'] = xX
--    },
--    [15] = {
--    ['NAME'] = "┣━━━━━━━━━━━━━━━━━\n┃[✵] 𝐓𝐮𝐧𝐧𝐞𝐥 𝐓𝐲𝐩𝐞 :",
--    ['DATA'] = active_mode
--    },
 
  }
  
local message = "```makefile\n┌────────────────────\n│     [  𝑵𝑷𝑽𝑻 𝑻𝑼𝑵𝑵𝑬𝑳  ]\n├────────────────────\n│[❖] 𝐂𝐨𝐝𝐞 𝐁𝐲: 𝑺𝒉𝒂𝒉𝒓𝒊𝒂𝒓_𝑿_𝑭𝒂𝒉𝒊𝒎\n├────────────────────\n│[❖] 𝐆𝐫𝐨𝐮𝐩 : t.me/Decrypt_VPN_Files\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..""..names.."  ' "..value.." ' \n"
           end
            end
        
            message = message.."├────────────────────\n│[❖] 𝐃𝐞𝐜 𝐁𝐲 : @Shahriar_X_Fahim\n└────────────────────\n```"
        local alert = gg.alert(message, "𝐂𝐎𝐏𝐘", "𝐄𝐗𝐈𝐓")
        if alert == 1 then
        gg.copyText(message, false)

        elseif alert == 2 then
        end
      io.open('/sdcard/npvtV2RAYc.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  os.exit()
  end




  function NpvtV2RAY2()
limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
--ProgressBar = "鈺戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈺?";for x = 1,15,1 do gg.sleep(40) ---ProgressBar = ProgressBar:gsub("鈻?","鈻?",1);gg.toast(ProgressBar) end
    io.open(gg.EXT_STORAGE .. "/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP)
---gg.makeRequest("https://raw.githubusercontent.com/EstebanZxx/Forbidden/main/KEY-ACCESS") key= W4nn4P14yW1thKyy 🐸🐸
gg.setVisible(false)
--gg.setVisible(false)
gg.searchNumber(":[lf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method2 = true
end

if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(":444@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method10 = true
end
end
if hc_method10 then
    gg.alert("No matching keywords!")
    os.exit()
end

local r = gg.getResults(100)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto inv谩lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inv谩lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "N茫o foi poss铆vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inv谩lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "N茫o foi poss铆vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "N茫o foi poss铆vel ler o conte煤do do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt"

    -- Abre o arquivo no modo de escrita no diret贸rio do script
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        -- Construir a string com os valores a serem salvos
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de sa铆da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depura莽茫o
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usu谩rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de sa铆da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt"
    local caminhoArquivoSaida = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    -- Criar ou abrir o arquivo de sa铆da
    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end

    -- Concatenar os resultados
local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
sshResults = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    -- Exibir e salvar os resultados
    exibirEInserir(arquivoSaida, " ", saida)
    
-- Fechar o arquivo de sa铆da
    arquivoSaida:close()
end    

processarSSHx()

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "***."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")

local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.")

function payloadx9()
function payload()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt
    local function payloadx()
        local arquivo = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
    ---        teste = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de sa铆da

    payloadx()
end

payload()
end

payloadx9()

function ovpnx9()
function ovpn()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt
    local function ovpnx()
        local arquivo = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end
             local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
---        testedd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de sa铆da

    ovpnx()
end

ovpn()
end

ovpnx9()

function v2rayx9()
function v2ray()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()
                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt
    local function v2rayx()
        local arquivo = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] 饾悤饾煇饾悜饾悮饾惒"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
 ---       testeddd= "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de sa铆da

    v2rayx()
end

v2ray()
end

v2rayx9()

function pythonx9()
function python()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedddd = (texto)
                local arquivoSaida = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt
    local function pythonx()
        local arquivo = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsPython = {'"ey', 'FRONTED-'}
    local labelPython = ""

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouPython = tentarEncontrarPalavrasChave(conteudo, keywordsPython, labelPython)

    if encontrouPython then
        print("")
    else
  --     testedddd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de sa铆da

    pythonx()
end

python()
end

pythonx9()

local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 

local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"

local sni = string.match(content, "[%w%.-]+:%d%d+[^馃槇]-\0([%w%.-]-%.[%w.-]-)\0") 

local ns  = string.match(content, "false") or "false"

local pubkey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65][%w.-]+.") 

local psiphon = string.match(content, "[\x5b]\x22.*]") or false

local versi = string.match(content, "645") or "645"

local xX = os.date("%d/%m/%Y %I:%M:%S")

--local xX = os.date("%I:%M %p")

function keyx9()
function key()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                pub = (texto) 
                local arquivoSaida = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt
    local function keyx()
        local arquivo = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"b22", "bc2c"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
     ---       pub = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de sa铆da

    keyx()
end

key()
end

keyx9()

function slowdnsx9()
function slowdns()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                name = (texto)
                local arquivoSaida = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt
    local function slowdnsx()
        local arquivo = io.open("/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsSlowdns = {"ns", "n%s-"}
        local labelSlowdns = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouSlowdns = tentarEncontrarPalavrasChave(conteudo, keywordsSlowdns, labelSlowdns)

        if encontrouSlowdns then
            print("")
        else
        --    name = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt" -- caminho do arquivo de sa铆da

    slowdnsx()
end

slowdns()
end

slowdnsx9()

local SlowDnsServer = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local PubKey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65]+")
local SSLSNI = string.match(content, "[%w]-%.[%w]-%.[%w]-")

local result = {
--    [1] = {
--    ['NAME'] = "\n│[ム] 𝐏𝐚𝐲𝐥𝐨𝐚𝐝 : ",
--    ['DATA'] = teste
--    },
--	[2] = {
--    ['NAME'] = "\n│[ム] 𝐏𝐫𝐨𝐱𝐲 : ",
--    ['DATA'] = proxy
--    },
--    [3] = {
--    ['NAME'] = "\n│[ム] 𝐒𝐒𝐇 : ",
--    ['DATA'] = sshResults
--    },
--    [4] = {
 --   ['NAME'] = "\n│[ム] 𝐒𝐒𝐋 : ",
--    ['DATA'] = SSLSNI
--    },
    [1] = {
    ['NAME'] = "\n│[✿] 𝐕2𝐑𝐀𝐘 : ",
    ['DATA'] = testeddd    },
--    [6] = {
--    ['NAME'] = "\n│[ム] 𝐏𝐒𝐈𝐏𝐇𝐎𝐍 : ",
--    ['DATA'] = testedddd
--    },
--    [7] = {
--    ['NAME'] = "\n│[ム] 𝐎𝐕𝐏𝐍 : ",
    ['DATA'] = testedd
--    },

  }
  
  local message = "```json\n┌────────────────────\n│[✿] 𝐂𝐨𝐝𝐞 𝐁𝐲 : @Shahriar_X_Fahim\n│[✿] 𝐆𝐫𝐨𝐮𝐩 : t.me/Decrypt_VPN_Files"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message.."\n├────────────────────"..names.." ' "..value.." ' "
           end
            end
         
            message = message.."\n├────────────────────\n│[✿] 𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐁𝐲 : @Shahriar_X_Fahim\n└────────────────────\n```"
        local alert = gg.alert(message, "𝐒𝐀𝐕𝐄", "𝐂𝐀𝐍𝐂𝐄𝐋")
        if alert == 1 then
        gg.copyText(message, false)
        gg.toast("Copied To Clipboard")
        elseif alert == 2 then
        end
      io.open('/sdcard/#𝐇𝐂-𝐍𝐏𝐕𝐓_🇧🇩.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  end











function DarkTunnel()
  function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, endereço fornecido é nulo.")
  
  _rw = {}

  if type(SizeOrBuffer) == "number" then
    _ = ""
    for SRD1_5_ = 1, SizeOrBuffer do
      _rw[SRD1_5_] = {
        address = Address - 1 + SRD1_5_,
        flags = gg.TYPE_BYTE
      }
    end

    for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
      if SRD1_6_.value == 0 and limit == true then
        return _
      end
      _ = _ .. string.format("%02X", SRD1_6_.value & 255)
    end

    return _
  end

  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end)

  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Não foi possível transmitir '" .. tostring(number) .. "' enumerar.'"))
end

function save(data)
  io.open("/sdcard/decrypt.txt", "w"):write(data)
end

limit = true
gg.clearResults()
gg.setVisible(false)
gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_C_DATA)
gg.setSpeed(20.0)

local function searchAndSave(searchText)
  gg.searchNumber(searchText, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local result = gg.getResults(1)

  if #result > 0 then
    if limit == false then
      result[1].address = result[1].address - 8192
    end
    readedMem = rwmem(result[1].address, 10000)
    save(hexdecode(readedMem))
    return true
  end

  return false
end

  local tests = {
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22 2C',
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22 2C',
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22',
    'h 3a 56 65 72 73 69 6f 6e 43 6f 64 65',
  }

local addressFound = false

for i, searchText in ipairs(tests) do
  if searchAndSave(searchText) then
    addressFound = true
    break
  end
end

if not addressFound then
  gg.alert("Decryption failed. Re-import the file and run the script.")
  
  
  os.exit()
end

local f = io.open("/sdcard/decrypt.txt", "r")
local dark = f:read("*all")
f:close()

dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')

dark = string.gsub(dark, "^%s*(.-)%s*$", "%1")

local f = io.open("/sdcard/decrypt.txt", "w")
f:write(dark)
f:close()

targetInfo = gg.getTargetInfo()
app = targetInfo.packageName
local label = gg.getTargetInfo().label or "N/A"

local currentDate = os.date("*t")
local data = os.date("%d/%m/%Y")

local message = "```makefile\n┌─[' @Shahriar_X_Fahim '] \n┊'⧼ 𝒮𝒽𝒶𝒽𝓇𝒾𝓇_𝒳_ℱ𝒶𝒽𝒾𝓂 ⧽'\n│'⧼ DARK TUNNEL ⧽'\n├───╼[' t.me/Decrypt_VPN_Files ']\n└──────────────────────\n┌──────────────────────\n│[❖] 𝗩2𝗥𝗔𝗬 :  ' " .. dark .. " ' \n└──────────────────────\n┌──────────────────────\n│[❖] 𝗗𝗲𝗰𝗿𝘆𝗽𝘁 𝗕𝘆 :' @Shahriar_X_Fahim'\n└──────────────────────\n```"

gg.alert(message, 'Copy and exit')
gg.copyText(message, false)

local f = io.open("/sdcard/decrypt.txt", "w")
f:write(message)
f:close()
gg.setVisible(false)
end

function HTTPCUSTOM3()
limit = false
 -- gg.setVisible(true)
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for _FORV_5_ = 1, SizeOrBuffer do
            _rw[_FORV_5_] = {
              address = Address - 1 + _FORV_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for _FORV_5_, _FORV_6_ in ipairs(gg.getValues(_rw)) do
            if _FORV_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", _FORV_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
  end
  
  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end
  
  function hexencode(str)
    return (str:gsub(".", function(char)
      return string.format("%2x", char:byte())
    end
    ))
  end
  
  function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
  end
  
    function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
  end
  
  function save(data)
    local function hexencode_spasi(str)
      return (str:gsub(".", function(char)
          return string.format("%02x ", char:byte())
      end))
    end

    local function checkMatch(key, str)
      result = nil
      
      for index, value in ipairs(key) do
          result = str:match(value)
          if result then 
              break 
          end
      end
      
      return result
    end

    local function strip(s)
      return (s:gsub("^%s*(.-)%s*$", "%1"))
    end

    local function prosesData(data)

      local function findExpDate(tbl)
          local key = {
              "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d",
              "lifeTime"
          } 
          local result = nil
          
          for index_tbl, value_tbl in ipairs(tbl) do
  
              for index_key, value_key in ipairs(key) do
                  
                  if value_tbl:match(value_key) then
                      result = index_tbl
                  end
  
              end
          end
          return result
      end
  
      local function splitString(str, separator)
          local match_1, match_2 = str:match("(.-)"..separator.."(.*)")
          local tbl = {}
  
          no = 1
          while (match_2:match("(.-)"..separator.."(.*)") and no < 100) do
      
              match_1, match_2 = match_2:match("(.-)"..separator.."(.*)")
      
              if hexdecode(match_1):match("[^\x20]+") then
                  table.insert(tbl, strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
              else 
                  table.insert(tbl,'')
              end
              
              no = no + 1
          end
  
          return tbl
      end
  
      local function fixedConfig(index, tbl)
          local result_fixedConfig = {}
          local beginIndex = index - 4
          local lastIndex = beginIndex + 31
  
          for i = beginIndex, lastIndex do
              table.insert(result_fixedConfig, tbl[i])
          end
  
          return result_fixedConfig
      end
      data = hexencode_spasi(data)
      data = data:gsub("00", "20")
      data = data:gsub("20", "z")
      data = data:gsub("66 61 6c 73 65", "F A L S E")
      data = data:gsub("\x20", "")
      data = data:gsub("\n", "")
      local separator = data:match("FALSE[\x7a]+(.-)[\x7a]+")
      data = data:gsub(separator, "0a56616c647947616e74656e67")
      separator = "0a56616c647947616e74656e67"
      data = data:gsub("z", "20")
      data = data:gsub("FALSE", "66616c7365")

      local result = splitString(data, separator)
      local assemblyPointIndex = findExpDate(result)
      local getConfig = fixedConfig(assemblyPointIndex, result)
  
      return getConfig
    end

    local function getOutput(tbl)
      local cfgRegex = {
        [1] = {
            ["name"] = "Payload",
            ["regex"] = "(.*)"  
     --   }, 
    --    [1] = {
        --    ["name"] = "Payload",
        --    ["regex"] = "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d]+"     
        },
        [2] = {
            ["name"] = "Proxy",
            ["regex"] = "(.*)"      
    --       ["regex"] = "[%w\x2e]+[\x3a][%d]+"
        },
        [3] = {
            ["name"] = "BlockRoot",
            ["regex"] = "(.*)"
        },
        [4] = {
            ["name"] = "ExtraSniffer",
            ["regex"] = "(.*)"
        },
        [5] = {
            ["name"] = "Expired",
            ["regex"] = "(.*)"
            
            
 --      },
  --     [6] = {
     --      ["name"] = "ExtraNotes",
    --      ["regex"] = "(.*)"
--       },
  --      [7] = {
   --      ["name"] = "Notes",
          -- ["regex"] = "(.*)"
         
        },
        [8] = {
            ["name"] = "Ssh", 
      --   ["regex"] = "(.*)"
         ["regex"] = "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+"
        },
        [9] = {
            ["name"] = "LockProvider",
            ["regex"] = "(.*)"
        },
        [10] = {
            ["name"] = "ProviderID", 
            ["regex"] = "[0-9]"
        },
        [11] = {
            ["name"] = "OpenVPN-Cerf",
            ["regex"] = "(.*)"
        },
        [12] = {
            ["name"] = "OpenVPN-User:Pass",
            ["regex"] = "(.*)"
        },
        [13] = {
            ["name"] = "SNI",
         ["regex"] = "(.*)"
          
        -- ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"

       },
        [15] = {
            ["name"] = "PortUDPGW",
            ["regex"] = "(.*)"
            
        },
        [17] = {
            ["name"] = "LockHWID",
            ["regex"] = "(.*)"
        },
        [18] = {
            ["name"] = "ValueHWID",
            ["regex"] = "(.*)"
            
        },
        [19] = {
            ["name"] = "NickPowerd",
            ["regex"] = "(.*)"
            
--        [20] = {
--            ["name"] = "@Shahriar_X_Fahim",
--            ["regex"] = "(.*)"
--        },
--        [21] = {
--            ["name"] = "URL",
--            ["regex"] = "(.*)"
        },
        [22] = {
            ["name"] = "BypassPassword",
            ["regex"] = "(.*)"
        },
        [23] = {
            ["name"] = "Password",
            ["regex"] = "[a-zA-Z0-9]"
        }, 
        [24] = {
            ["name"] = "PsihonMode",
            ["regex"] = "(.*)"            
        }, 
        [25] = {
            ["name"] = "PsiphonAuthorizon",
            --["regex"] = "(.*)"      
           ["regex"] = "[\x5b]\x22.*]"
            
        },   
        [26] = {
            ["name"] = "V2RayMode",
            ["regex"] = "(.*)"
        },
        [27] = {
            ["name"] = "V2Ray",
            ["regex"] = "(.*)"
        },
        [29] = {
         ["name"] = "SlowDNSMode", 
         ["regex"] = "(.*)" 
                    
       }, 
        [28] = {
            ["name"] = "VerApp",
            ["regex"] = "(.*)"
       },
        [30] = {
            ["name"] = "NameServer",
       --     ["regex"] = "(.*)"
      ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"
        },
        [31] = {
            ["name"] = "Public Key", 
         --   ["regex"] = "(.*)"
           ["regex"] = "[a-f0-9]+[32,64,50,66,61,6c,73,65]+"
        },
        [32] = {
            ["name"] = "DNS Host",
         --   ["regex"] = "(.*)"
            ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"
        }
    }
       
      
      local message = "```java\n'⧼ Shahriar_X_Fahim ⧽ '\n' t.me/Decrypt_VPN_Files '\n\n{ \n\n     ''HttpCustom Decrypt'': \n"
      
      for index, value in ipairs(tbl) do
          
          if cfgRegex[index] and value:match(cfgRegex[index]["regex"]) then
              local namaKonten = cfgRegex[index]["name"]
              local valueRegexKonten = value:match(cfgRegex[index]["regex"])
  
              message = message.."     ''"
              message = message..namaKonten.."'': ''"..valueRegexKonten.."'',\n"
          end
          
      end
  
      message = message.."\n}\n```"
      return message
    end


    local contentToDecrypt = hexdecode(data)
    contentToDecrypt = prosesData(hexdecode(data))
    local hasil = getOutput(contentToDecrypt)
    io.open(gg.EXT_STORAGE .. "/#HC_JAVA🇧🇩.txt", "w"):write(hexdecode(data))
     
    gg.copyText(hasil, false)
    gg.toast(hasil)
    print(hasil)
 end

 gg.setVisible(false)
-- gg.processPause()
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setSpeed(20.0)
  gg.searchNumber(":GET / HTTP", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("KEY 1")
    hc_method2 = true
  end
  if hc_method2 then
    gg.searchNumber("Host: ", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 2")
      hc_method3 = true
    end
  end
  if hc_method3 then
    gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 3")
      hc_method4 = true
    end
  end
  if hc_method4 then
    gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 4")
      hc_method5 = true
    end
  end
  if hc_method5 then
    gg.searchNumber("Upgrade: websocket", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 5")
      hc_method6 = true
    end
  end
  if hc_method6 then
    gg.searchNumber(":GET wss:", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 6")
      hc_method7 = true
    end
  end
  if hc_method7 then
    gg.searchNumber(":[splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 7")
      hc_method8 = true
    end
  end
  if hc_method8 then
    print("All methods failed")
    os.exit()
  end

    local r = gg.getResults(1)
  if limit == false then
    r[1].address = r[1].address - 0x2000
  end 
  readedMem = rwmem(r[1].address, 15000)
  save(readedMem)
  gg.clearResults()
end







function HTTPCUSTOM2()
limit = false
 -- gg.setVisible(true)
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for _FORV_5_ = 1, SizeOrBuffer do
            _rw[_FORV_5_] = {
              address = Address - 1 + _FORV_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for _FORV_5_, _FORV_6_ in ipairs(gg.getValues(_rw)) do
            if _FORV_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", _FORV_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
  end
  
  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end
  
  function hexencode(str)
    return (str:gsub(".", function(char)
      return string.format("%2x", char:byte())
    end
    ))
  end
  
  function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
  end
  
    function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
  end
  
  function save(data)
    local function hexencode_spasi(str)
      return (str:gsub(".", function(char)
          return string.format("%02x ", char:byte())
      end))
    end

    local function checkMatch(key, str)
      result = nil
      
      for index, value in ipairs(key) do
          result = str:match(value)
          if result then 
              break 
          end
      end
      
      return result
    end

    local function strip(s)
      return (s:gsub("^%s*(.-)%s*$", "%1"))
    end

    local function prosesData(data)

      local function findExpDate(tbl)
          local key = {
              "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d",
              "lifeTime"
          } 
          local result = nil
          
          for index_tbl, value_tbl in ipairs(tbl) do
  
              for index_key, value_key in ipairs(key) do
                  
                  if value_tbl:match(value_key) then
                      result = index_tbl
                  end
  
              end
          end
          return result
      end
  
      local function splitString(str, separator)
          local match_1, match_2 = str:match("(.-)"..separator.."(.*)")
          local tbl = {}
  
          no = 1
          while (match_2:match("(.-)"..separator.."(.*)") and no < 100) do
      
              match_1, match_2 = match_2:match("(.-)"..separator.."(.*)")
      
              if hexdecode(match_1):match("[^\x20]+") then
                  table.insert(tbl, strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
              else 
                  table.insert(tbl,'')
              end
              
              no = no + 1
          end
  
          return tbl
      end
  
      local function fixedConfig(index, tbl)
          local result_fixedConfig = {}
          local beginIndex = index - 4
          local lastIndex = beginIndex + 31
  
          for i = beginIndex, lastIndex do
              table.insert(result_fixedConfig, tbl[i])
          end
  
          return result_fixedConfig
      end
      data = hexencode_spasi(data)
      data = data:gsub("00", "20")
      data = data:gsub("20", "z")
      data = data:gsub("66 61 6c 73 65", "F A L S E")
      data = data:gsub("\x20", "")
      data = data:gsub("\n", "")
      local separator = data:match("FALSE[\x7a]+(.-)[\x7a]+")
      data = data:gsub(separator, "0a56616c647947616e74656e67")
      separator = "0a56616c647947616e74656e67"
      data = data:gsub("z", "20")
      data = data:gsub("FALSE", "66616c7365")

      local result = splitString(data, separator)
      local assemblyPointIndex = findExpDate(result)
      local getConfig = fixedConfig(assemblyPointIndex, result)
  
      return getConfig
    end

    local function getOutput(tbl)
      local cfgRegex = {
        [1] = {
            ["name"] = "Payload",
            ["regex"] = "(.*)"  
     --   }, 
    --    [1] = {
        --    ["name"] = "Payload",
        --    ["regex"] = "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d]+"     
        },
        [2] = {
            ["name"] = "Proxy",
            ["regex"] = "(.*)"      
    --       ["regex"] = "[%w\x2e]+[\x3a][%d]+"
        },
        [3] = {
            ["name"] = "BlockRoot",
            ["regex"] = "(.*)"
        },
        [4] = {
            ["name"] = "ExtraSniffer",
            ["regex"] = "(.*)"
        },
        [5] = {
            ["name"] = "Expired",
            ["regex"] = "(.*)"
            
            
 --      },
  --     [6] = {
     --      ["name"] = "ExtraNotes",
    --      ["regex"] = "(.*)"
--       },
  --      [7] = {
   --      ["name"] = "Notes",
          -- ["regex"] = "(.*)"
         
        },
        [8] = {
            ["name"] = "Ssh", 
      --   ["regex"] = "(.*)"
         ["regex"] = "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+"
        },
        [9] = {
            ["name"] = "LockProvider",
            ["regex"] = "(.*)"
        },
        [10] = {
            ["name"] = "ProviderID", 
            ["regex"] = "[0-9]"
        },
        [11] = {
            ["name"] = "OpenVPN-Cerf",
            ["regex"] = "(.*)"
        },
        [12] = {
            ["name"] = "OpenVPN-User:Pass",
            ["regex"] = "(.*)"
        },
        [13] = {
            ["name"] = "SNI",
         ["regex"] = "(.*)"
          
        -- ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"

       },
        [15] = {
            ["name"] = "PortUDPGW",
            ["regex"] = "(.*)"
            
        },
        [17] = {
            ["name"] = "LockHWID",
            ["regex"] = "(.*)"
        },
        [18] = {
            ["name"] = "ValueHWID",
            ["regex"] = "(.*)"
            
        },
        [19] = {
            ["name"] = "NickPowerd",
            ["regex"] = "(.*)"
            
--        [20] = {
--            ["name"] = "@Shahriar_X_Fahim",
--            ["regex"] = "(.*)"
--        },
--        [21] = {
--            ["name"] = "URL",
--            ["regex"] = "(.*)"
        },
        [22] = {
            ["name"] = "BypassPassword",
            ["regex"] = "(.*)"
        },
        [23] = {
            ["name"] = "Password",
            ["regex"] = "[a-zA-Z0-9]"
        }, 
        [24] = {
            ["name"] = "PsihonMode",
            ["regex"] = "(.*)"            
        }, 
        [25] = {
            ["name"] = "PsiphonAuthorizon",
            --["regex"] = "(.*)"      
           ["regex"] = "[\x5b]\x22.*]"
            
        },   
        [26] = {
            ["name"] = "V2RayMode",
            ["regex"] = "(.*)"
        },
        [27] = {
            ["name"] = "V2Ray",
            ["regex"] = "(.*)"
        },
        [29] = {
         ["name"] = "SlowDNSMode", 
         ["regex"] = "(.*)" 
                    
       }, 
        [28] = {
            ["name"] = "VerApp",
            ["regex"] = "(.*)"
       },
        [30] = {
            ["name"] = "NameServer",
       --     ["regex"] = "(.*)"
      ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"
        },
        [31] = {
            ["name"] = "Public Key", 
         --   ["regex"] = "(.*)"
           ["regex"] = "[a-f0-9]+[32,64,50,66,61,6c,73,65]+"
        },
        [32] = {
            ["name"] = "DNS Host",
         --   ["regex"] = "(.*)"
            ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"
        }
    }
       
      
      local message = "```java\n⧼ Shahriar_X_Fahim ⧽ \nt.me/Decrypt_VPN_Files \n\n{ \n\n     ''HttpCustom Decrypt'': \n"
      
      for index, value in ipairs(tbl) do
          
          if cfgRegex[index] and value:match(cfgRegex[index]["regex"]) then
              local namaKonten = cfgRegex[index]["name"]
              local valueRegexKonten = value:match(cfgRegex[index]["regex"])
  
              message = message.."     ''"
              message = message..namaKonten.."'': ''"..valueRegexKonten.."'',\n"
          end
          
      end
  
      message = message.."\n}\n```"
      return message
    end


    local contentToDecrypt = hexdecode(data)
    contentToDecrypt = prosesData(hexdecode(data))
    local hasil = getOutput(contentToDecrypt)
    io.open(gg.EXT_STORAGE .. "/#HC_JAVA🇧🇩.txt", "w"):write(hexdecode(data))
     
    gg.copyText(hasil, false)
    gg.toast(hasil)
    print(hasil)
 end

 gg.setVisible(false)
-- gg.processPause()
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setSpeed(20.0)
  gg.searchNumber(":GET / HTTP", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("KEY 1")
    hc_method2 = true
  end
  if hc_method2 then
    gg.searchNumber("Host: ", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 2")
      hc_method3 = true
    end
  end
  if hc_method3 then
    gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 3")
      hc_method4 = true
    end
  end
  if hc_method4 then
    gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 4")
      hc_method5 = true
    end
  end
  if hc_method5 then
    gg.searchNumber("Upgrade: websocket", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 5")
      hc_method6 = true
    end
  end
  if hc_method6 then
    gg.searchNumber(":GET wss:", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 6")
      hc_method7 = true
    end
  end
  if hc_method7 then
    gg.searchNumber(":[splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 7")
      hc_method8 = true
    end
  end
  if hc_method8 then
    print("All methods failed")
    os.exit()
  end

    local r = gg.getResults(1)
  if limit == false then
    r[1].address = r[1].address - 0x2000
  end 
  readedMem = rwmem(r[1].address, 15000)
  save(readedMem)
  gg.clearResults()
end












function HC()
limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
--ProgressBar = "鈺戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈻戔枒鈺?";for x = 1,15,1 do gg.sleep(40) ---ProgressBar = ProgressBar:gsub("鈻?","鈻?",1);gg.toast(ProgressBar) end
    io.open(gg.EXT_STORAGE .. "/HTTP_CUSTOM.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP)
---gg.makeRequest("https://raw.githubusercontent.com/EstebanZxx/Forbidden/main/KEY-ACCESS") key= W4nn4P14yW1thKyy 🐸🐸
gg.setVisible(false)
--gg.setVisible(false)
gg.searchNumber(":[lf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method2 = true
end

if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(":444@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method10 = true
end
end
if hc_method10 then
    gg.alert("No matching keywords!")
    os.exit()
end

local r = gg.getResults(100)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/HTTP_CUSTOM.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/HTTP_CUSTOM.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto inv谩lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inv谩lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "N茫o foi poss铆vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inv谩lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "N茫o foi poss铆vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "N茫o foi poss铆vel ler o conte煤do do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/HTTP_CUSTOM.txt"

    -- Abre o arquivo no modo de escrita no diret贸rio do script
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        -- Construir a string com os valores a serem salvos
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de sa铆da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depura莽茫o
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usu谩rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de sa铆da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt"
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    -- Criar ou abrir o arquivo de sa铆da
    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end

    -- Concatenar os resultados
local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
sshResults = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    -- Exibir e salvar os resultados
    exibirEInserir(arquivoSaida, " ", saida)
    
-- Fechar o arquivo de sa铆da
    arquivoSaida:close()
end    

processarSSHx()

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "***."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")

local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.")

function payloadx9()
function payload()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function payloadx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
    ---        teste = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    payloadx()
end

payload()
end

payloadx9()

function ovpnx9()
function ovpn()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function ovpnx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
---        testedd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    ovpnx()
end

ovpn()
end

ovpnx9()

function v2rayx9()
function v2ray()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function v2rayx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] 饾悤饾煇饾悜饾悮饾惒"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
 ---       testeddd= "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    v2rayx()
end

v2ray()
end

v2rayx9()

function pythonx9()
function python()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedddd = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function pythonx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsPython = {'"ey', 'FRONTED-'}
    local labelPython = ""

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouPython = tentarEncontrarPalavrasChave(conteudo, keywordsPython, labelPython)

    if encontrouPython then
        print("")
    else
  --     testedddd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    pythonx()
end

python()
end

pythonx9()

local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 

local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"

local sni = string.match(content, "[%w%.-]+:%d%d+[^馃槇]-\0([%w%.-]-%.[%w.-]-)\0") 

local ns  = string.match(content, "false") or "false"

local pubkey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65][%w.-]+.") 

local psiphon = string.match(content, "[\x5b]\x22.*]") or false

local versi = string.match(content, "645") or "645"

local xX = os.date("%d/%m/%Y %I:%M:%S")

--local xX = os.date("%I:%M %p")

function keyx9()
function key()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                pub = (texto) 
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function keyx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"b22", "bc2c"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
     ---       pub = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    keyx()
end

key()
end

keyx9()

function slowdnsx9()
function slowdns()
    -- Fun莽茫o para remover bytes nulos do in铆cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Fun莽茫o para tentar encontrar palavras-chave e salvar informa莽玫es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para tr谩s at茅 encontrar o in铆cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente at茅 encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                name = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de sa铆da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Fun莽茫o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function slowdnsx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsSlowdns = {"ns", "n%s-"}
        local labelSlowdns = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouSlowdns = tentarEncontrarPalavrasChave(conteudo, keywordsSlowdns, labelSlowdns)

        if encontrouSlowdns then
            print("")
        else
        --    name = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de sa铆da

    slowdnsx()
end

slowdns()
end

slowdnsx9()

local SlowDnsServer = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local PubKey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65]+")
local SSLSNI = string.match(content, "[%w]-%.[%w]-%.[%w]-")

local result = {
    [1] = {
    ['NAME'] = "\n│[✩] 𝐒𝐒𝐇 : ",
    ['DATA'] = teste
    },
	[2] = {
    ['NAME'] = "\n│[✩] 𝐏𝐑𝐎𝐗𝐘 : ",
    ['DATA'] = proxy
    },
    [3] = {
    ['NAME'] = "\n│[✩] 𝐒𝐒𝐇 : ",
    ['DATA'] = sshResults
    },
    [4] = {
    ['NAME'] = "\n│[✩] 𝐒𝐒𝐋 : ",
    ['DATA'] = SSLSNI
    },
    [5] = {
    ['NAME'] = "\n│[✩] 𝐕2𝐑𝐀𝐘 : ",
    ['DATA'] = testeddd
    },
    [6] = {
    ['NAME'] = "\n│[✩] 𝐏𝐒𝐈𝐏𝐇𝐎𝐍 : ",
    ['DATA'] = testedddd
    },
    [7] = {
    ['NAME'] = "\n│[✩] 𝐎𝐕𝐏𝐍 : ",
    ['DATA'] = testedd
    },

  }
  
      local message = "```makefile\n┌────────────────────\n│[✩] 𝐂𝐎𝐃𝐄 𝐁𝐘 : @Shahriar_X_Fahim\n├────────────────────\n│[✩] 𝐆𝐑𝐎𝐔𝐏 : t.me/Decrypt_VPN_Files"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message.."\n├────────────────────"..names.." ' "..value.." ' "
           end
            end
         
            message = message.."\n├────────────────────\n│[✩] 𝐃𝐄𝐂 𝐁𝐘 : @Shahriar_X_Fahim\n└────────────────────\n```"
        local alert = gg.alert(message, "𝐒𝐀𝐕𝐄", "𝐄𝐗𝐈𝐓")
        if alert == 1 then
        gg.copyText(message, false)
        gg.toast("Copied To Clipboard")
        elseif alert == 2 then
        end
      io.open('/sdcard/HTTP_CUSTOM.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  end


function HcDNS()

limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
gg.toast("Decrypt Successful")
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_ANONYMOUS)
gg.setSpeed(20.0)
gg.setVisible(false)

gg.searchNumber(":lf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then   
    hc_method2 = true
end
if hc_method2 then 
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(':22@', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":143@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':dns.', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method9 = true
    
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method10 = true
end
end

if hc_method10 then 
gg.searchNumber("h 5D 48 6F 73 74", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method11 = true
end
end


if hc_method11 then 
gg.searchNumber("h 5D 00 48 00 6F 00 73 00 74 00", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method12 = true
end
end

if hc_method12 then 
gg.searchNumber(":]User", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method13 = true
end
end

if hc_method13 then 
gg.searchNumber(":]Upgrade", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method14 = true
end
end

if hc_method14 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method15 = true
end
end


if hc_method15 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method16 = true
end
end


if hc_method16 then 
gg.searchNumber(":edfe9c3", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method17 = true
end
end





if hc_method17 then
gg.alert("Failed All Key ")
os.exit()
end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto inválido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "Não foi possível ler o conteúdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/decrypt.txt"

    -- Abre o arquivo no modo de escrita no diretório do script
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        -- Construir a string com os valores a serem salvos
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saída")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depuração
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usuário e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saída: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end


local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    exibirEInserir(arquivoSaida, " ", saida)
    
    arquivoSaida:close()
end    

processarSSHx()

function payloadx9()
function payload()
    -- Função para remover bytes nulos do início e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Função para tentar encontrar palavras-chave e salvar informações
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trás até encontrar o início real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente até encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end
        local function payloadx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
            teste = " "
        end
    end

    local caminhoArquivoEntrada = "/sdcard/decrypt.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/hc.txt" -- caminho do arquivo de saída

    payloadx()
end

payload()
end

payloadx9()

function ovpnx9()
function ovpn()
    -- Função para remover bytes nulos do início e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Função para tentar encontrar palavras-chave e salvar informações
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trás até encontrar o início real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente até encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Função para decodificar a payload e salvar no arquivo /sdcard/decrypt.txt
    local function ovpnx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
        testedd = " "
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/hc.txt" -- caminho do arquivo de saída

    ovpnx()
end

ovpn()
end

ovpnx9()

function v2rayx9()
function v2ray()
    -- Função para remover bytes nulos do início e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Função para tentar encontrar palavras-chave e salvar informações
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trás até encontrar o início real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente até encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Função para decodificar a payload e salvar no arquivo /sdcard/decrypt.txt
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = ""

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
        testeddd= " "
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/hc.txt" -- caminho do arquivo de saída

    v2rayx()
end

v2ray()
end

v2rayx9()

-- Don't move this string
local start = "```makefile\n┌──────────────────────\n│[✩] 𝐆𝐫𝐨𝐮𝐩 :' t.me/Decrypt_VPN_Files '\n├──────────────────────\n│[✩] 𝐂𝐨𝐝𝐞 𝐁𝐲 : '@Shahriar_X_Fahim '\n"
local final = "├──────────────────────\n│[✩] 𝐃𝐞𝐜 𝐁𝐲 :' @Shahriar_X_Fahim '\n└──────────────────────\n```"

-- Payload filter string and ssh no encrypt
local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5blf\x5d+]+") or " "
local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.")

-- Psiphon filter string
local psiph = string.match(content, '[%S]+FRONTED') or " "
local psi = string.match(content, '%FRONTED.-[%w]+[%S][%w]+') or " "

-- Proxy filter string & SNI
local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+\0") or " "
local sni = string.match(content, "[%w%.-]+:%d%d+[^😈]-\0([%w%.-]-%.[%w.-]-)\0") or " "

-- slowdns filter string
local pubkey = string.match(content, "[a-zA-Z0-9-]+[a-zA-Z]+[a-zA-Z]+[1,63]+%d%w+") or " "
local dns = string.match(content, "%d%d+[^😈]-\0([%d%.-]-%.[%d.-]-)\0") or " "
local server = string.match(content, "%w%w+[^😈]-\0([%w%.-]-%.[%w.-]-)\0\0") or " "

-- More filter string
local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"
local versi = string.match(content, "645") or "645"
local xX = os.date("%d/%m/%Y %I:%M:%S") or " "
local hwid = string.match(content, "false") or "false"
local udpw = string.match(content, "7300") or "7300"

-- do not edit this string
local message = start

local function Shahriar_X_Fahim(label, value)
  if value and value ~= "" then
    message = message .. "├──────────────────────\n│[☼] [" .. label .. "] :  ' " .. value .. " ' \n"
  end
end

Shahriar_X_Fahim("𝐒𝐒𝐇 𝐀𝐝𝐝𝐫𝐞𝐬𝐬", result)
--Shahriar_X_Fahim("𝐒𝐒𝐇", SSH)
Shahriar_X_Fahim("𝐏𝐚𝐲𝐥𝐨𝐚𝐝", PAYLOADD)
Shahriar_X_Fahim("𝐏𝐫𝐨𝐱𝐲", proxy)
Shahriar_X_Fahim("𝐒𝐍𝐈", sni)
Shahriar_X_Fahim("𝐕𝟐𝐫𝐚𝐲", testeddd)
Shahriar_X_Fahim("𝐍𝐚𝐦𝐞𝐒𝐞𝐫𝐯𝐞𝐫", server)
Shahriar_X_Fahim("𝐃𝐨𝐦𝐚𝐢𝐧𝐃𝐍𝐒", dns)
Shahriar_X_Fahim("𝐏𝐮𝐛𝐥𝐢𝐜 𝐊𝐞𝐲", pubkey)
Shahriar_X_Fahim("𝐎𝐯𝐩𝐧𝐂𝐞𝐫𝐭", testedd)
Shahriar_X_Fahim("𝐔𝐃𝐏 𝐀𝐝𝐝𝐫𝐞𝐬𝐬", udpgw)
Shahriar_X_Fahim("𝐏𝐬𝐢𝐩𝐡𝐨𝐧𝐀𝐮𝐭𝐡𝐨𝐫𝐢𝐳𝐚𝐭𝐢𝐨𝐧", psiph)
Shahriar_X_Fahim("𝐏𝐬𝐢𝐩𝐡𝐨𝐧𝐏𝐫𝐨𝐭𝐨𝐜𝐨𝐥", psi)
Shahriar_X_Fahim("𝐇𝐖𝐈𝐃", hwid)
Shahriar_X_Fahim("𝐄𝐱𝐩𝐢𝐫𝐚𝐭𝐢𝐨𝐧", life)

if message ~= "" then
  message = message .. final
  gg.alert(message, '𝐂𝐎𝐏𝐘 & 𝐄𝐗𝐈𝐓')
  gg.copyText(message, false)
end

local f = io.open("/sdcard/hc_3.txt", "w")
f:write(message)

gg.clearResults()
  end


function V2RAY2()

--t.me/Shhriar_X_Fahim

limit = false
targetInfo = gg.getTargetInfo()
gg.clearResults()
app = targetInfo.packageName
local utf8 = {}
local bit = {
  data32 = {}
}
do
  do
    for SRD1_5_ = 1, 32 do
      bit.data32[SRD1_5_] = 2 ^ (32 - SRD1_5_)
    end
  end
end
local toby = string.byte
function utf8.charbytes(s, i)
  i = i or 1
  local c = string.byte(s, i)
  if c > 0 and c <= 127 then
    do return 1 end
    return
  end
  if c >= 194 and c <= 223 then
    do return 2 end
    return
  end
  if c >= 224 and c <= 239 then
    do return 3 end
    return
  end
  if c >= 240 and c <= 244 then
    return 4
  end
  return 1
end

local ded
function bit:d2b(arg)
  if arg == nil then
    return
  end
  local tr, c = {}, arg < 0
  if c then
    arg = 0 - arg
  end
  do
    do
      for SRD1_7_ = 1, 32 do
        if arg >= self.data32[SRD1_7_] then
          tr[SRD1_7_] = 1
          arg = arg - self.data32[SRD1_7_]
        else
          tr[SRD1_7_] = 0
        end
      end
    end
  end
  if c then
    tr = self:_bnot(tr)
    tr = self:b2d(tr) + 1
    tr = self:d2b(tr)
  end
  return tr
end
---Blue And Desert @DecryptConfig Project

function bit:b2d(arg, neg)
  local nr = 0
  if arg[1] == 1 and neg == true then
    arg = self:_bnot(arg)
    nr = self:b2d(arg) + 1
    nr = 0 - nr
  else
    do
      for SRD1_7_ = 1, 32 do
        if arg[SRD1_7_] == 1 then
          nr = nr + 2 ^ (32 - SRD1_7_)
        end
      end
    end
  end
  return nr
end
function bit:_and(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 and op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_or(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 or op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_xor(a, b)
  local op1 = self:d2b(a)
  if op1 == nil then
    return nil
  end
  local op2 = self:d2b(b)
  if op2 == nil then
    return nil
  end
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == op2[SRD1_9_] then
          r[SRD1_9_] = 0
        else
          r[SRD1_9_] = 1
        end
      end
    end
  end
  return self:b2d(r, true)
end

local switch = {
  [1] = function(s, pos)
    local c1 = toby(s, pos)
    return c1
  end
  ,
  [2] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local int1 = bit:_and(31, c1)
    local int2 = bit:_and(63, c2)
    return bit:_or(bit:_lshift(int1, 6), int2)
  end
  ,
  [3] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local o2 = bit:_or(bit:_lshift(int1, 12), bit:_lshift(int2, 6))
    local dt = bit:_or(o2, int3)
    return dt
  end
  ,
  [4] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local c4 = toby(s, pos + 3)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local int4 = bit:_and(63, c4)
    local o2 = bit:_or(bit:_lshift(int1, 18), bit:_lshift(int2, 12))
    local o3 = bit:_or(o2, bit:_lshift(int3, 6))
    local o4 = bit:_or(o3, int4)
    return o4
  end
  
}
function bit:_bnot(op1)
  local r = {}
  do
    do
      for SRD1_6_ = 1, 32 do
        if op1[SRD1_6_] == 1 then
          r[SRD1_6_] = 0
        else
          r[SRD1_6_] = 1
        end
      end
    end
  end
  return r
end

function bit:_not(a)
  local op1 = self:d2b(a)
  local r = self:_bnot(op1)
  return self:b2d(r, true)
end

function bit:charCodeAt(s)
  local pos, int, H, L = 1, 0, 0, 0
  local slen = string.len(s)
  local allByte = {}
  while pos <= slen do
    local tLen = utf8.charbytes(s, pos)
    if tLen >= 1 and tLen <= 4 then
      if tLen == 4 then
        int = switch[4](s, pos)
        H = math.floor((int - 65536) / 1024) + 55296
        L = (int - 65536) % 1024 + 56320
        table.insert(allByte, H)
        table.insert(allByte, L)
      else
        int = switch[tLen](s, pos)
        table.insert(allByte, int)
      end
    end
    pos = pos + tLen
  end
  return allByte
end

function bit:_rshift(a, n)
  local r = 0
  if a < 0 then
    r = 0 - self:_frshift(0 - a, n)
  elseif a >= 0 then
    r = self:_frshift(a, n)
  end
  return r
end

function bit:_frshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  local left = 32 - n
  if n < 32 and n > 0 then
    do
      for SRD1_9_ = left, 1, -1 do
        r[SRD1_9_ + n] = op1[SRD1_9_]
      end
    end
  end
  return self:b2d(r)
end

function bit:_lshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  if n < 32 and n > 0 then
    do
      for SRD1_8_ = n, 31 do
        r[SRD1_8_ - n + 1] = op1[SRD1_8_ + 1]
      end
    end
  end
  return self:b2d(r, true)
end

function trim(s)
  return s:match("^%s*(.*)"):match("(.-)%s*$")
end

local json = {}
local kind_of = function(obj)
  if type(obj) ~= "table" then
    return type(obj)
  end
  local i = 1
  do
    do
      for SRD1_5_ in pairs(obj) do
        if obj[i] ~= nil then
          i = i + 1
        else
          return "table"
        end
      end
    end
  end
  if i == 1 then
    do return "table" end
    return
  end
  return "array"
end

local escape_str = function(s)
  local in_char = {
    "\\",
    "\"",
    "/",
    "\b",
    "\f",
    "\n",
    "\r",
    "\t"
  }
  local out_char = {
    "\\",
    "\"",
    "/",
    "b",
    "f",
    "n",
    "r",
    "t"
  }
  do
    do
      for SRD1_6_, SRD1_7_ in ipairs(in_char) do
        s = s:gsub(SRD1_7_, "\\" .. out_char[SRD1_6_])
      end
    end
  end
  return s
end

local skip_delim = function(str, pos, delim, err_if_missing)
  pos = pos + #str:match("^%s*", pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error("Esperado " .. delim .. " posição próxima " .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

local function parse_str_val(str, pos, val)
  val = val or ""
  local early_end_error = "Fim da entrada encontrado durante a análise da string."
  if pos > #str then
    error(early_end_error)
  end
  local c = str:sub(pos, pos)
  if c == "\"" then
    return val, pos + 1
  end
  if c ~= "\\" then
    return parse_str_val(str, pos + 1, val .. c)
  end
  local esc_map = {
    b = "\b",
    f = "\f",
    n = "\n",
    r = "\r",
    t = "\t"
  }
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then
    error(early_end_error)
  end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

local parse_num_val = function(str, pos)
  local num_str = str:match("^-?%d+%.?%d*[eE]?[+-]?%d*", pos)
  local val = tonumber(num_str)
  if not val then
    error("Erro ao analisar o número na posição " .. pos .. ".")
  end
  return val, pos + #num_str
end

function json.stringify(obj, as_key)
  local s = {}
  local kind = kind_of(obj)
  if kind == "array" then
    if as_key then
      error("Não é possível codificar array como chave.")
    end
    s[#s + 1] = "["
    do
      do
        for SRD1_7_, SRD1_8_ in ipairs(obj) do
          if SRD1_7_ > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "]"
  elseif kind == "table" then
    if as_key then
      error("Não é possível codificar a tabela como chave.")
    end
    s[#s + 1] = "{"
    do
      do
        for SRD1_7_, SRD1_8_ in pairs(obj) do
          if #s > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_7_, true)
          s[#s + 1] = ":"
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "}"
  else
    if kind == "string" then
      do return "\"" .. escape_str(obj) .. "\"" end
      return
    end
    if kind == "number" then
      if as_key then
        return "\"" .. tostring(obj) .. "\""
      end
      do return tostring(obj) end
      return
    end
    if kind == "boolean" then
      do return tostring(obj) end
      return
    end
    if kind == "nil" then
      do return "null" end
      return
    end
    error("tipo unjsonificável,: " .. kind .. ".")
  end
  return table.concat(s)
end

json.null = {}
function json.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then
    error("Atingiu o fim inesperado da entrada ")
  end
  local pos = pos + #str:match("^%s*", pos)
  local first = str:sub(pos, pos)
  if first == "{" then
    do
      local obj, key, delim_found = {}, true, true
      pos = pos + 1
      while true do
        key, pos = json.parse(str, pos, "}")
        if key == nil then
          return obj, pos
        end
        if not delim_found then
          error("Vírgula faltando entre os itens do objeto.")
        end
        pos = skip_delim(str, pos, ":", true)
        obj[key], pos = json.parse(str, pos)
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "[" then
    do
      local arr, val, delim_found = {}, true, true
      pos = pos + 1
      while true do
        val, pos = json.parse(str, pos, "]")
        if val == nil then
          return arr, pos
        end
        if not delim_found then
          error("Falta vírgula entre os itens do array.")
        end
        arr[#arr + 1] = val
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "\"" then
    do return parse_str_val(str, pos + 1) end
    return
  end
  if first == "-" or first:match("%d") then
    do return parse_num_val(str, pos) end
    return
  end
  if first == end_delim then
    do return nil, pos + 1 end
    return
  end
  do
    local literals = {
      ["true"] = true,
      ["false"] = false,
      null = json.null
    }
    do
      do
        for SRD1_9_, SRD1_10_ in pairs(literals) do
          local lit_end = pos + #SRD1_9_ - 1
          if str:sub(pos, lit_end) == SRD1_9_ then
            return SRD1_10_, lit_end + 1
          end
        end
      end
    end
    local pos_info_str = "position " .. pos .. ": " .. str:sub(pos, pos + 10)
    error("Sintaxe json inválida começando em " .. pos_info_str)
  end
end

function enc(data, b)
  return (data:gsub(".", function(x)
    local r, b = "", x:byte()
    do
      do
        for SRD1_6_ = 8, 1, -1 do
          r = r .. (b % 2 ^ SRD1_6_ - b % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
    if #x < 6 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 6 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (6 - SRD1_5_) or 0)
        end
      end
    end
    return b:sub(c + 1, c + 1)
  end
  ) .. ({
    "",
    "??",
    "?"
  })[#data % 3 + 1]
end

function dec(data, b)
  data = string.gsub(data, "[^" .. b .. "=]", "")
  return (data:gsub(".", function(x)
    if x == "?" then
      return ""
    end
    local r, f = "", b:find(x) - 1
    do
      do
        for SRD1_6_ = 6, 1, -1 do
          r = r .. (f % 2 ^ SRD1_6_ - f % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
    if #x ~= 8 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 8 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (8 - SRD1_5_) or 0)
        end
      end
    end
    return string.char(c)
  end
  ))
end
function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, endereço fornecido é nulo.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Não foi possível transmitir '" .. tostring(number) .. "' enumerar.'"))
end
  local load ='LOADING: '
  
function save(data)
io.open("/sdcard/v2🇧🇩.txt", "w"):write(data)
  gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
  for i = 1, 5 do
load = load..'◉‿◉'
gg.toast(load)
gg.sleep(1)
end
end

function save2(data)
  io.open(gg.EXT_STORAGE .. "/sdcard/v2🇧🇩.txt", "w"):write(json.stringify(data))
  gg.toast("!")
end

function rwmem(Address, SizeOrBuffer)
	assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
	_rw = {}


	if type(SizeOrBuffer) == "number" then
		_ = ""
		for _ = 1, SizeOrBuffer do _rw[_] = {address = (Address - 1) + _, flags = gg.TYPE_BYTE} end
		for v, __ in ipairs(gg.getValues(_rw)) do
			if __.value == 00 and limit == true then
		return _
		end
		_ = _ .. string.format("%02X", __.value & 0xFF)
		
end
		return _
	end
	Byte = {} SizeOrBuffer:gsub("..", function(x)
		Byte[#Byte + 1] = x _rw[#Byte] = {address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h"}	end)
    gg.setValues(_rw)
end


  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_PPSSPP | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_BAD)
  gg.setSpeed(20.0)
  gg.setVisible(false)
  gg.searchNumber("h 7B 0A 09 09 22 69 6E 62 6F 75 6E 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("inbounds")
    hc_2 = true
  end
  if hc_2 then 
    gg.searchNumber("h 7B 0A 09 09 22 64 6E 73 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("dns")
      hc_3 = true
    end
  end
  if hc_3 then
    gg.searchNumber("h 20 22 64 6e 73 22 3a 20 7b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_4 = true
    end
  end
  if hc_4 then
    gg.searchNumber("h 7B 0A 09 09 09 09 09 09 09 09 09 09 09 09 22 61 64 64 72 65 73 73 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("address")
      hc_5 = true
    end
  end
  if hc_5 then
    gg.searchNumber("h 22 6c 6f 67 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
      hc_6 = true
    end
  end
  if hc_6 then
    gg.searchNumber("h 22 6f 75 74 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("outbounds")
      hc_7 = true
    end
  end
  if hc_7 then
    gg.toast("⧼ 𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐚𝐡𝐢𝐦 ⧽")
    print("all metode failed\n")
    os.exit()
  end
  local r = gg.getResults(1000)
  if limit == false then
    r[1].address = r[1].address - 0x400
  end
readedMem = rwmem(r[3].address, 50000)
save(hexdecode(readedMem))
gg.clearResults()

local f = io.open("/sdcard/v2🇧🇩.txt", "r")
 local content = f:read(3000)
 content= content:gsub("%c","")
 f:close()

---Blue And Desert @DecryptConfig Project

 local muxEnabled = content:match('"mux"%s*:%s*{[^}]-"enabled"%s*:%s*(%a+)')
  local address = content:match('"address"%s*:%s*"(.-)"')
 local protocol = content:match('"protocol"%s*:%s*"([^"]+)"')
 local address = content:match('"address"%s*:%s*"(.-)"')
 local port = tonumber(content:match('"port"%s*:%s*(%d+)'))
 local alterId = tonumber(content:match('"alterId"%s*:%s*(%d+)'))
 local id = content:match('"id"%s*:%s*"(.-)"')
 local level = tonumber(content:match('"level"%s*:%s*(%d+)'))
 local security = content:match('"security"%s*:%s*"([^"]+)"')
 local network = content:match('"network"%s*:%s*"([^"]+)"')
 local host = content:match('"Host"%s*:%s*"(.-)"')
 local path = content:match('"path"%s*:%s*"(.-)"')
 local tag = content:match('"tag"%s*:%s*"(.-)"')
 local connIdle = tonumber(content:match('"connIdle"%s*:%s*(%d+)'))
 local downlinkOnly = tonumber(content:match('"downlinkOnly"%s*:%s*(%d+)'))
 local handshake = tonumber(content:match('"handshake"%s*:%s*(%d+)'))
 local uplinkOnly = tonumber(content:match('"uplinkOnly"%s*:%s*(%d+)'))
 local allowInsecure = content:match('"allowInsecure"%s*:%s*(%a+)')
 local serverName = content:match('"serverName"%s*:%s*"(.-)"')
 
 
 local result = {
[1] = {
      ['name'] = '│[☆] 𝐏𝐫𝐨𝐭𝐨𝐜𝐨𝐥',
      ['regex'] = protocol,
    },
[2] = {
      ['name'] = '│[☆] 𝐒𝐞𝐫𝐯𝐞𝐫𝐀𝐝𝐫𝐞𝐬𝐬',
      ['regex'] = address,
    },
[3] = {
      ['name'] = '│[☆] 𝐏𝐨𝐫𝐭',
      ['regex'] = port,
    },
[4] = {
      ['name'] = '│[☆] 𝐀𝐥𝐭𝐞𝐫𝐈𝐃',
      ['regex'] = alterId,
    },
[5] = {
      ['name'] = '│[☆] 𝐈𝐃',
      ['regex'] = id,
    },
[6] = {
      ['name'] = '│[☆] 𝐋𝐞𝐯𝐞𝐥',
      ['regex'] = level,
    },
[7] = {
      ['name'] = '│[☆] 𝐒𝐞𝐜𝐮𝐫𝐢𝐭𝐲',
      ['regex'] = security,
    },
[8] = {
      ['name'] = '│[☆] 𝐍𝐞𝐭𝐰𝐨𝐫𝐤',
      ['regex'] = network
    },
[9] = {
      ['name'] = '│[☆] 𝐓𝐋𝐒𝐒𝐞𝐜𝐮𝐫𝐢𝐭𝐲',
      ['regex'] = tlssecurity,
    },
[10] = {
      ['name'] = '│[☆] 𝐀𝐥𝐥𝐨𝐰𝐈𝐧𝐬𝐞𝐜𝐮𝐫𝐞',
      ['regex'] = allowInsecure,
    },
[11] = {
      ['name'] = '│[☆] 𝐒𝐞𝐫𝐯𝐞𝐫𝐍𝐚𝐦𝐞',
      ['regex'] = serverName,
    },
[12] = {
      ['name'] = '│[☆] 𝐇𝐨𝐬𝐭',
      ['regex'] = host,
    },
[13] = {
      ['name'] = '│[☆] 𝐏𝐚𝐭𝐡',
      ['regex'] = path,
    },
[14] = {
      ['name'] = '│[☆] 𝐓𝐚𝐠',
      ['regex'] = tag,
    },
[15] = {
      ['name'] = '│[☆] 𝐂𝐨𝐧𝐧𝐢𝐝𝐥𝐞',
      ['regex'] = connIdle,
    },
[16] = {
      ['name'] = '│[☆] 𝐃𝐨𝐰𝐧𝐋𝐢𝐧𝐤𝐎𝐧𝐥𝐲',
      ['regex'] = downlinkOnly,
    },
[17] = {
      ['name'] = '│[☆] 𝐇𝐚𝐧𝐝𝐒𝐡𝐚𝐤𝐞',
      ['regex'] = handshake,
    },
[18] = {
      ['name'] = '│[☆] 𝐔𝐩𝐋𝐢𝐧𝐤𝐎𝐧𝐥𝐲',
      ['regex'] = uplinkOnly,
    },
}
 
  ---@Shahriar_X_Fahim 
  
  
    local message = "```sql\n┌─[ @Shahriar_X_Fahim ] \n┊⧼ 𝒮𝒽𝒶𝒽𝓇𝒾𝓇_𝒳_ℱ𝒶𝒽𝒾𝓂 ⧽\n│⧼ 𝐕2𝐑𝐀𝐘 𝐀𝐋𝐋 ⧽\n├───╼[ t.me/Decrypt_VPN_Files ]\n└──────────────────────\n" .. '\n'
  

message = message .. '┌──────────────────────\n'

 for i, v in ipairs(result) do
  if result[i] and result[i]['regex'] then
    message = message..result[i]['name'].." ≫︎ ' "..''..''..result[i]['regex']..''.." ' \n├──────────────────────\n"

end
end


message = message .. '└──────────────────────\n'

  message = message .. '┌──────────────────────\n│[☆] 𝐃𝐞𝐜 𝐁𝐲 : @Shahriar_X_Fahim\n└──────────────────────\n```'
 

    
    
    
    
    

  
 gg.copyText(message, false)
 gg.alert(message, "𝐂𝐎𝐏𝐘")
-- gg.toast(message .. [[

--]])

io.open("/sdcard/Result🇧🇩.txt", "w"):write(message)
gg.isVisible(true)
 gg.clearResults()
end


function darktunnel2()
-- Function to read and write memory
function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is null.")

  local _rw = {}

  if type(SizeOrBuffer) == "number" then
    local result = ""
    for i = 1, SizeOrBuffer do
      _rw[i] = {
        address = Address - 1 + i,
        flags = gg.TYPE_BYTE
      }
    end

    for _, value in ipairs(gg.getValues(_rw)) do
      if value.value == 0 and limit == true then
        return result
      end
      result = result .. string.format("%02X", value.value & 255)
    end

    return result
  end

  local Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end)

  gg.setValues(_rw)
end

-- Function to decode hexadecimal to string
function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end))
end

-- Function to clean and filter non-printable characters
function cleanText(str)
  return (str:gsub("[\0-\31\127]", ""))
end

-- Manually format JSON with indentation
function formatJsonManually(jsonText)
  local indent = 0
  local formatted = ""
  local inString = false
  local prevChar = ""

  -- Loop through each character and add indentation
  for i = 1, #jsonText do
    local currentChar = jsonText:sub(i, i)

    if currentChar == '"' and prevChar ~= "\\" then
      inString = not inString
    end

    if inString then
      formatted = formatted .. currentChar
    else
      if currentChar == "{" or currentChar == "[" then
        formatted = formatted .. currentChar .. "\n"
        indent = indent + 1
        formatted = formatted .. string.rep("  ", indent)
      elseif currentChar == "}" or currentChar == "]" then
        formatted = formatted .. "\n"
        indent = indent - 1
        formatted = formatted .. string.rep("  ", indent) .. currentChar
      elseif currentChar == "," then
        formatted = formatted .. currentChar .. "\n"
        formatted = formatted .. string.rep("  ", indent)
      else
        formatted = formatted .. currentChar
      end
    end

    prevChar = currentChar
  end

  return formatted
end

-- Save data to a file
function save(data)
  local file = io.open("/sdcard/decrypt.txt", "w")
  file:write(data)
  file:close()
end

-- Main function that controls the decryption process
  limit = true
  gg.clearResults()
  gg.setVisible(true)
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_C_DATA)

  -- Function to search and save specific data
  local function searchAndSave(searchText)
    gg.searchNumber(searchText, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local result = gg.getResults(1)

    if #result > 0 then
      if limit == false then
        result[1].address = result[1].address - 8192
      end
      local readedMem = rwmem(result[1].address, 10000)
      save(hexdecode(readedMem))
      return true
    end

    return false
  end

  -- List of tests with specific byte patterns
  local tests = {
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22 2C',
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22 2C',
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22',
    'h 3a 56 65 72 73 69 6f 6e 43 6f 64 65',
  }

  -- Attempt to search and save one of the tests
  local addressFound = false

  for _, searchText in ipairs(tests) do
    if searchAndSave(searchText) then
      addressFound = true
      break
    end
  end

  -- If no address is found, show an alert and exit
  if not addressFound then
    gg.alert("Decryption failed. Re-import the file and run the script.")
    os.exit()
  end

  -- Read the decrypted data from the file
  local file = io.open("/sdcard/decrypt.txt", "r")
  local dark = file:read("*all")
  file:close()

  -- Clean the text (remove non-printable characters)
  dark = cleanText(dark)

  -- If it's JSON-like data, format it manually
  if dark:sub(1, 1) == "{" or dark:sub(1, 1) == "[" then
    dark = formatJsonManually(dark)
  end

  -- Prepare the header
  local header = [[
```yaml
┌──•❀•❀  𝘿𝙖𝙧𝙠 𝙏𝙐𝙉𝙉𝙀𝙇  ❀•❀•──┐
├➢ 𝘾𝙤𝙙𝙚 𝘽𝙮 : [𝐒𝐡𝐚𝐡𝐫𝐢𝐚𝐫_𝐗_𝐅𝐀𝐇𝐈𝐌]
├➢ 𝙏𝙂 : t.me/Decrypt_VPN_Files
└─────────────────────────┘
┌────────────•••────────────
└┈➤  𝙑2𝙧𝙖𝙮 : 
]]

  -- Prepare the footer
  local footer = [[
┌───────────────────────────┐
├┈➤ 𝗗𝗲𝗰𝗿𝘆𝗽𝘁 𝗕𝘆 : @Shahriar_X_Fahim
└───────────────────────────┘
```
]]

  -- Wrap the JSON data with the "Json" markers
  local jsonWrapped = "\n" .. dark .. "\n"

  -- Combine header, JSON wrapped data, and footer
  local message = header .. "\n" .. jsonWrapped .. "\n" .. footer

  -- Save the combined message to the file
  save(message)

  -- Copy text including header, formatted JSON, and footer
  gg.alert(message, '𝐂𝐎𝐏𝐘 𝐀𝐍𝐃 𝐄𝐗𝐈𝐓')
  gg.copyText(message, false)

  -- Save the message to the file
  save(message)

  -- Hide GameGuardian interface
  gg.setVisible(false)

-- Call the DarkTunnel function to execute the script
  gg.clearResults()
end








function tls()

function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open("results.txt", "w"):write(data)
end
  limit = false
    gg.clearResults()
    gg.setVisible(false)
    gg.processPause()
    gg.searchNumber(':{"A":', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
        tls_2 = true
    end
    if tls_2 then
        gg.searchNumber(':"z":"', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_3 = true
        end
    end
    if tls_3 then
        gg.searchNumber(':"z":"', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_4 = true
        end
    end
        if tls_4 then
        gg.searchNumber(':" z " : " ', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_5 = true
        end
    end
        if tls_5 then
        gg.searchNumber(':" z " : " ', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_6 = true
        end
    end
    if tls_6 then
    gg.searchNumber(':" z " : " ', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_7 = true
        end
    end
    if tls_7 then
        gg.processResume()
    gg.alert("Decryption failed re-import the file and run the script")
    gg.toast("❑  𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐅𝐚𝐢𝐥𝐞𝐝!  ❑") 
    gg.processResume()
    os.exit()
  end
      local r = gg.getResults(1)
  if limit == false then
    r[1].address = r[1].address +100
    end
  readedMem = rwmem(r[1].address, 8000)
  save(hexdecode(readedMem))
  gg.processResume()
  gg.clearResults()

local f = io.open("results.txt", "r")
local content = f:read("*all")
f:close()

content = content:gsub("[%z\1-\31\127-\159\226\128-\235]", '')

local f = io.open("results.txt", "w")
 f:write(content)
 f:close()

local startMessage = "```makefile\n┌──────────────────────\n│' ⧼ 𝐃𝐄𝐂𝐑𝐘𝐏𝐓 𝐓𝐋𝐒 𝐓𝐔𝐍𝐍𝐄𝐋 ⧽'\n├───────────────────────\n│[✩] 𝐆𝐫𝐨𝐮𝐩 :' t.me/Decrypt_VPN_Files '\n"
local endMessage = "├───────────────────────\n│[✩] 𝐃𝐞𝐜 𝐁𝐲 : '@Shahriar_X_Fahim '\n└──────────────────────\n```"

local A = content:match('"A":(%a+)')
local B = content:match('"B":(%a+)')
local C = content:match('"C":(%a+)')
local D = content:match('"D":"(.-)"')
local E = content:match('"E":(%a+)')
local F = content:match('"F":(%a+)')
local a = content:match('"a":(%a+)')
local b = content:match('"b":(%d+)')
local c = content:match('"c":(%d+)')
local d = content:match('"d":(%d+)')
local e = content:match('"e":(%a+)')
local f = content:match('"f":"(.-)"')
local g = content:match('"g":"(.-)"')
local h = content:match('"h":"(.-)"')
local i = content:match('"i":"(.-)"')
local j = content:match('"j":"(.-)"')
local k = content:match('"k":"(.-)"')
local l = content:match('"l":(%d+)')
local m = content:match('"m":(%a+)')
local n = content:match('"n":"(.-)"')
local o = content:match('"o":(%a+)')
local p = content:match('"p":"(.-)"')
local q = content:match('"q":(%a+)')
local r = content:match('"r":"(.-)"')
local s = content:match('"s":(%a+)')
local t = content:match('"t":"(.-)"')
local u = content:match('"u":"(.-)"')
local v = content:match('"v":(%d+)')
local w = content:match('"w":"(.-)"')
local x = content:match('"x":"(.-)"')
local y = content:match('"y":"(.-)"')
local z = content:match('"z":"(.-)"')

local alertMessage = startMessage

-- Función para agregar al mensaje de alerta
local function appendToAlert(label, value)
  if value and value ~= "" then
    alertMessage = alertMessage .. "├───────────────────────\n│[✩] " .. label .. " :'" .. value .. "'\n"
  end
end

appendToAlert("𝐒𝐞𝐫𝐯𝐞𝐫", h)
appendToAlert("𝐏𝐨𝐫𝐭", i)
appendToAlert("𝐔𝐬𝐞𝐫𝐧𝐚𝐦𝐞", f)
appendToAlert("𝐏𝐚𝐬𝐬𝐨𝐰𝐫𝐝", g)
appendToAlert("𝐏𝐫𝐢𝐯𝐞𝐭 𝐒𝐞𝐫𝐯𝐞𝐫", j)
appendToAlert("𝐏𝐫𝐢𝐯𝐞𝐭 𝐏𝐨𝐫𝐭", k)
appendToAlert("𝐏𝐚𝐲𝐥𝐨𝐚𝐝", n)
appendToAlert("𝐒𝐍𝐈", p)
appendToAlert("𝐏𝐚𝐲𝐥𝐨𝐚𝐝 𝐀𝐟𝐭𝐞𝐫 𝐓𝐋𝐒", r)
appendToAlert("𝐂𝐨𝐧𝐧𝐞𝐜𝐭𝐢𝐨𝐧 𝐓𝐲𝐩𝐞", s)
appendToAlert("𝐒𝐞𝐫𝐯𝐞𝐫 𝐏𝐫𝐨𝐱𝐲", t)
appendToAlert("𝐏𝐨𝐫𝐭", u)
appendToAlert("𝐃𝐍𝐒 𝐒𝐞𝐫𝐯𝐞𝐫", w)
appendToAlert("𝐃𝐍𝐒 𝐏𝐨𝐫𝐭", x)
appendToAlert("𝐑𝐞𝐪𝐮𝐞𝐬𝐭 𝐃𝐨𝐦𝐚𝐢𝐧", y)
appendToAlert("𝐏𝐮𝐛𝐥𝐢𝐜 𝐊𝐞𝐲", z)
appendToAlert("𝐕𝐞𝐫𝐢𝐨𝐧 𝐀𝐩𝐩", b)

if alertMessage ~= startMessage then
  alertMessage = alertMessage .. endMessage
  gg.alert(alertMessage, 'copy and exit')
  gg.copyText(alertMessage, false)
  gg.toast("⎙  𝐃𝐞𝐜𝐫𝐲𝐩𝐭 𝐒𝐮𝐜𝐜𝐞𝐬𝐬!  ⎙")
end

local file = io.open("Tls_Tunnel.txt", "w")
file:write(alertMessage)

  gg.setVisible(false)
  gg.clearResults()
end



function HTTP3()
  limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_ANONYMOUS)
gg.setVisible(false)
gg.setSpeed(20.0)
gg.searchNumber(":[host]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then   
    hc_method2 = true
end
if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(':[splitPsiphon', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method10 = true
end


end
if hc_method10 then
gg.alert("KEYWORD NOT FOUND")
os.exit()
end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto inválido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo inválido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "Não foi possível abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "Não foi possível ler o conteúdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/decrypt.txt"

    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saída")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)

    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usuário e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saída: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end


local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    exibirEInserir(arquivoSaida, " ", saida)
    
    arquivoSaida:close()
end    

processarSSHx()

function payloadSF()
function payload()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function payloadx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
        end
    end

    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    payloadx()
end

payload()
end

payloadSF()

function ovpnSF()
function ovpn()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function ovpnx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    ovpnx()
end

ovpn()
end

ovpnSF()

function v2raySF()
function v2ray()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saída.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

   
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] 𝐕𝟐𝐑𝐚𝐲"

    
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    v2rayx()
end

v2ray()
end

v2raySF()

local mode = {
"SSH ➔ Payload & V2ray",
"V2ray",
"SSH ➔ Payload",
"SSL ➔ SSH ➔ Direct",
"OpenVPN ➔ Payload",
"Payload ➔ OpenVPN",
"OpenVPN",
"V2ray ➔ Payload",
"SSH ➔ Direct",
"SSH ➔ Payload",
"Psiphon ➔ Payload",
"Payload",
}
local active_mode = ""
if pas and teste and proxy and testeddd then
active_mode = mode[1]
elseif testeddd then
active_mode = mode[2]
elseif host and teste then
active_mode = mode[3]
elseif sni and pas then
active_mode = mode[4]
elseif testedd then
active_mode = mode[5]
elseif teste and proxy and testedd then
active_mode = mode[6]
elseif testedd then
active_mode = mode[7]
elseif testeddd and teste then
active_mode = mode[8]
elseif pas then
active_mode = mode[9]
elseif SSH then
active_mode = mode[10]
elseif psiph and teste then
active_mode = mode[11]
elseif teste and proxy then
active_mode = mode[12]
else
active_mode = "";
end

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "*."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")
local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.") 
local psiph = string.match(content, '[%S]+FRONTED')
local psi = string.match(content, '%FRONTED.-[%w]+[%S][%w]+') 
local server = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 
local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"
local sni = string.match(content, "[%w%.-]+:%d%d+[^ ]-\0([%w%.-]-%.[%w.-]-)\0") 
local versi = string.match(content, "645") or "645"
local xX = os.date("%d/%m/%Y %I:%M:%S")

local result = {
    [1] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗛𝗢𝗦𝗧✓ : ",
    ['DATA'] = host
    },
    [2] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗣𝗢𝗥𝗧✓ : ",
    ['DATA'] = port
    },
    [3] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗨𝗦𝗘𝗥✓ : ",
    ['DATA'] = hostt
    },
    [4] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗣𝗔𝗦𝗦✓ : ",
    ['DATA'] = pas
    },
    [5] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗣𝗮𝘆𝗹𝗼𝗮𝗱 : ",
    ['DATA'] = teste
    },
    [6] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗣𝗿𝗼𝘅𝘆 : ",
    ['DATA'] = proxy
    },
	[7] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗢𝗽𝗲𝗻𝗩𝗣𝗡 : ",
    ['DATA'] = testedd
    },
    [8] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗦𝗦𝗛 : ",
    ['DATA'] = SSH
    },
    [9] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗦𝗦𝗟 : ",
    ['DATA'] = sni
    },
    [10] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗩2𝗿𝗮𝘆 : ",
    ['DATA'] = testeddd
    },
    [11] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗣𝘀𝗶𝗽𝗷𝗼𝗻 𝗔𝘂𝘁𝗵𝗼𝗿𝗶𝘇𝗮𝘁𝗶𝗼𝗻",
    ['DATA'] = psiph
    },
    [12] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗣𝘀𝗶𝗽𝗵𝗼𝗻 𝗣𝗿𝗼𝘁𝗼𝗰𝗼𝗹",
    ['DATA'] = psi
    },
    [13] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗩𝗲𝗿𝘀𝗶𝗼𝗻 : ",
    ['DATA'] = versi
    },
    [14] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗧𝗶𝗺𝗲 : ",
    ['DATA'] = xX
    },
    [15] = {
    ['NAME'] = "┌──────────•••───────────\n╰┈➤ 𝗧𝘂𝗻𝗻𝗲𝗹 𝗧𝘆𝗽𝗲 :",
    ['DATA'] = active_mode
    },
 
  }
  
      local message = "```yaml\n╭─•❀•❀ 𝙃𝙏𝙏𝙋 𝘾𝙐𝙎𝙏𝙊𝙈 ❀•❀•─╮\n├➢ t.me/Decrypt_VPN_Files\n╰──────────────────────╯\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..""..names.." ' "..value.." ' \n"
           end
            end
        
            message = message.."┌──────────•••───────────\n├┈➤ 𝗗𝗲𝗰𝗿𝘆𝗽𝘁 𝗕𝘆 : @Shahriar_X_Fahim\n└──────────•••───────────\n```"
        local alert = gg.alert(message, "𝐂𝐎𝐏𝐘", "𝐄𝐗𝐈𝐓")
        if alert == 1 then
        gg.copyText(message, false)

        elseif alert == 2 then
        end
      io.open('/sdcard/hc.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  end








function LOBBY()
  
  gg.skipRestoreState()
  gg.setVisible(true)
  os.exit()
end

while true do
  if gg.isVisible(true) then
    LuaLibraryTool = 1
    gg.setVisible(false)
  end
  if LuaLibraryTool == 1 then
    HOME()
  end
end