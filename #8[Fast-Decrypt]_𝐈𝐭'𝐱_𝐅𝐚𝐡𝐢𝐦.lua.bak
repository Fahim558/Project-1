

limit = false
targetInfo = gg.getTargetInfo()
app = targetInfo.packageName
filename = gg.getFile():match("[^/]+$")
if filename ~= "#8[Fast-Decrypt]_ğˆğ­'ğ±_ğ…ğšğ¡ğ¢ğ¦.lua" then
  print("âš  ğƒğ¨ ğ§ğ¨ğ­ ğœğ¡ğšğ§ğ ğ ğŸğ¢ğ¥ğ ğ§ğšğ¦ğ , ğ©ğ¥ğğšğ¬ğ ğ«ğğ¬ğ­ğ¨ğ«ğ ğ­ğ¨ ğ¨ğ«ğ¢ğ ğ¢ğ§ğšğ¥ ğ§ğšğ¦ğ!\nâ™› ğğ«ğ¢ğ ğ¢ğ§ğšğ¥ ğğšğ¦ğ â¤â˜Ÿï¸ï¸ï¸\n#8[Fast-Decrypt]_ğˆğ­'ğ±_ğ…ğšğ¡ğ¢ğ¦.lua")
  os.exit()
end


-- Check status from GitHub
local currentVersion = "1.0" -- Change this when releasing new versions

-- ğŸ”— Remote JSON config
local configURL = "https://raw.githubusercontent.com/Fahim558/Project-1/main/script_config.json"
local configReq = gg.makeRequest(configURL)

if not configReq.content then
    gg.alert("âŒ Cannot connect to server. Check your internet.")
    os.exit()
end

-- ğŸ”„ Parse JSON (manual method)
local ok, config = pcall(function() return load("return " .. configReq.content)() end)
if not ok or not config then
    gg.alert("âŒ Invalid config format.")
    os.exit()
end

-- ğŸš« Remote OFF
if config.status ~= "on" then
    gg.alert("ğŸš« Script is OFF by the developer.")
    os.exit()
end

-- ğŸ”„ Version mismatch
if config.version ~= currentVersion then
    local force = config.force_update or false

    gg.alert("ğŸ†• Update Required!\n\nğŸ“Œ New Version: " .. config.version ..
             "\n\n" .. (config.changelog or "No changelog."))

    if force then
        gg.alert("âš ï¸ You must update to continue...")

        local updateReq = gg.makeRequest(config.update_url)
        if updateReq.content then
            -- âš ï¸ OVERWRITE current script
            local scriptPath = "/storage/emulated/0/Download/#8[Fast-Decrypt]_ğˆğ­'ğ±_ğ…ğšğ¡ğ¢ğ¦.lua"
            local f = io.open(scriptPath, "w")
            f:write(updateReq.content)
            f:close()
            gg.alert("âœ… Updated successfully!\nFile overwritten:\n*#8[Fast-Decrypt]_ğˆğ­'ğ±_ğ…ğšğ¡ğ¢ğ¦.lua*")
        else
            gg.alert("âŒ Failed to download update.")
        end
        os.exit()
    end
end

-- âœ… Continue if latest
gg.alert("âœ… Script is ON (v" .. currentVersion .. "). Welcome!")



-- ğŸ”½ Ekhane tumar main menu/function add koro


gg.setVisible(true)
LuaLibraryTool = -1
function HOME()
  local menu = gg.multiChoice({
    "âœ… HTTP CUSTOM [1]",
    "âœ… HTTP CUSTOM [2]",
    "âœ… HTTP CUSTOM [3]",
    "âœ… HTTP CUSTOM [JSON]",
    "âœ… HTTP CUSTOM [BETA]",
    "âœ… V2RAY ALL [1]",
    "âœ… V2RAY ALL [2]",
    "âœ… HC UDP",
    "âœ… HC SSH",
    "âœ… PSIPHON",
    "âœ… SSC CUSTOM [NORMAL]",
    "âœ… SSC CUSTOM {JSON}",
    "âœ… NPVT V2RAY [1]",
    "âœ… NPVT V2RAY [2]",
    "âœ… NPVT SSH",
    "âœ… SocksIP",
    "âœ… TLS TUNNEL",
    "âœ… DARK TUNNEL [1]", 
    "âœ… DARK TUNNEL [2]",     
    
    "âŒ EXIT"
  }, nil, os.date([[
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒğ—–ğ—¢ğ——ğ—˜ ğ—•ğ—¬ â§¼ ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿_ğ—«_ğ—™ğ—”ğ—›ğ—œğ—  â§½
â”ƒğ—šğ—¥ğ—¢ğ—¨ğ—£ : t.me/Decrypt_VPN_Files 
â”ƒğ—¨ğ—¡ğ—Ÿğ—¢ğ—–ğ— ğ—§ğ—¢ğ—¢ğ—Ÿğ—¦
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒâ€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢ğ—¨ğ—¡ğ—Ÿğ—¢ğ—–ğ— ğ—§ğ—¢ğ—¢ğ—Ÿğ—¦â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

]]))

  if menu == nil then return end

  if menu[1] then HTTPCustom() end
  if menu[2] then HC() end
  if menu[3] then HTTP3() end  
  if menu[4] then HTTPCUSTOM3() end
  if menu[5] then HcDNS() end
  if menu[6] then V2RAY() end
  if menu[7] then V2RAY2() end 
  if menu[8] then UDPNEW() end 
  if menu[9] then SSHDEC() end
  if menu[10] then Fahim() end
  if menu[11] then SSCCustom() end
  if menu[12] then SSC() end
  if menu[13] then Npvtv2ray() end 
  if menu[14] then NpvtV2RAY2() end  
  if menu[15] then NpvtSSH() end 
  if menu[16] then sip() end  
  if menu[17] then tls() end  
  if menu[18] then DarkTunnel() end   
  if menu[19] then darktunnel2() end      
  if menu[20] then LOBBY() end
end

LuaLibraryTool = -1



function SSC()
  gg.clearResults()
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setVisible(false)
  gg.setSpeed(20.0)
  gg.searchNumber(':{"ab', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—º")
    ssc_method2 = true
  end
  if ssc_method2 then
    gg.searchNumber("h 55 70 67 72 61 64 65 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—º")
      ssc_method3 = true
    end
  end
  if ssc_method3 then
    gg.searchNumber("h 3A 38 30 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—º")
      ssc_method4 = true
    end
  end
  if ssc_method4 then
    limit = true
    gg.searchNumber("h 7B A 9 9 22 69 6E 62 6F 75 6E 64 73 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—º")
      ssc_method5 = true
    end
  end

  if ssc_method5 then
    limit = true
    gg.searchNumber("h 7B 0A 20 20 22 64 6E 73 22 3A 20 7B 0A 20 20 20 20 22 68 6F 73 74 73 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—º")
      ssc_method6 = true
    end
  end
  if ssc_method6 then
    limit = false
    gg.searchNumber("h 3A 35 33 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—º")
      ssc_method7 = true
    end
  end
  if ssc_method7 then
    limit = false
    gg.searchNumber("h 5B 73 70 6C 69 74 50 73 69 70 68 6F 6E 5D 5B 73 70 6C 69 74 50 73 69 70 68 6F 6E 5D", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—º")
      ssc_method8 = true
    end
    
    
  end
  if hc_method8 then
    print("en:")
    print("âŒ All methods failed, try with a different file.\n")
    os.exit()
  end
  local r = gg.getResults(1000)
  if limit == false then
    r[1].address = r[1].address - 8192
  end
  readedMem = rwmem(r[1].address, 50000)
  save(hexdecode(readedMem))
  print("âœ… Successfully!\n\nFile: /sdcard/decryptSSC.txt")
  gg.clearResults()
end
      



function SSHDEC()
limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/peler.txt", "w"):write(hexdecode(data))
    gg.toast("<!> â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğ€ğ‡ğˆğŒ â§½ <!>")
end

gg.setRanges(gg.REGION_JAVA_HEAP)
gg.setSpeed(20.0)
gg.setVisible(false)
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("443")
    hc_method2 = true
end

if hc_method2 then
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("2082")
    hc_method3 = true
end
end
if hc_method3 then
gg.searchNumber(":2082@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("8880")
    hc_method4 = true
end
end
if hc_method4 then
gg.searchNumber(":8880@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("444")
    hc_method5 = true
end
end
if hc_method5 then
gg.searchNumber(":444@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("53")
    hc_method6 = true
end
end
if hc_method6 then
gg.searchNumber(":53@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("22")
    hc_method7 = true
end
end
if hc_method7 then
gg.searchNumber(":22@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    gg.toast("73")
    hc_method8 = true
end
end
if hc_method8 then
    print("SSH Not Found")
    os.exit()
end

local r = gg.getResults(1)
if limit == false then
    r[1].address = r[1].address - 100
end

readedMem = rwmem(r[1].address, 600)
save(readedMem)
gg.clearResults()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto invÃ¡lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "NÃ£o foi possÃ­vel ler o conteÃºdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "print.txt"

    ---DONT REMOVE !!
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        ---DONT EDIT VALUE
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        
        outputFile:close()
    else
        print("")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depuraÃ§Ã£o
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "UsuÃ¡rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
gg.alert(result, "copy")
gg.copyText(result, false)
    local sucesso, erro = arquivoSaida:write(result .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saÃ­da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/peler.txt"
    local caminhoArquivoSaida = "hc_.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("SSH Not Encrypt ğŸ¥´")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        print("SSH Not Encyrption")
        return
    end

    ---XXXXXGENZ
    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        print("SSH Not Found ")
        return
    end

   --DONT REMOVE !!!! 
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    
    exibirEInserir(arquivoSaida, " ", saida)

    ---XXGENZ
    arquivoSaida:close()
end

processarSSHx()
end

function HTTPCustom()
  limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_ANONYMOUS)
gg.setVisible(false)
gg.setSpeed(20.0)
gg.searchNumber(":[host]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then   
    hc_method2 = true
end
if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(':[splitPsiphon', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method10 = true
end


end
if hc_method10 then
gg.alert("KEYWORD NOT FOUND")
os.exit()
end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto invÃ¡lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "NÃ£o foi possÃ­vel ler o conteÃºdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/decrypt.txt"

    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saÃ­da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)

    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "UsuÃ¡rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saÃ­da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end


local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    exibirEInserir(arquivoSaida, " ", saida)
    
    arquivoSaida:close()
end    

processarSSHx()

function payloadSF()
function payload()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function payloadx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
        end
    end

    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    payloadx()
end

payload()
end

payloadSF()

function ovpnSF()
function ovpn()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function ovpnx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    ovpnx()
end

ovpn()
end

ovpnSF()

function v2raySF()
function v2ray()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

   
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] ğ•ğŸğ‘ğšğ²"

    
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    v2rayx()
end

v2ray()
end

v2raySF()

local mode = {
"SSH â” Payload & V2ray",
"V2ray",
"SSH â” Payload",
"SSL â” SSH â” Direct",
"OpenVPN â” Payload",
"Payload â” OpenVPN",
"OpenVPN",
"V2ray â” Payload",
"SSH â” Direct",
"SSH â” Payload",
"Psiphon â” Payload",
"Payload",
}
local active_mode = ""
if pas and teste and proxy and testeddd then
active_mode = mode[1]
elseif testeddd then
active_mode = mode[2]
elseif host and teste then
active_mode = mode[3]
elseif sni and pas then
active_mode = mode[4]
elseif testedd then
active_mode = mode[5]
elseif teste and proxy and testedd then
active_mode = mode[6]
elseif testedd then
active_mode = mode[7]
elseif testeddd and teste then
active_mode = mode[8]
elseif pas then
active_mode = mode[9]
elseif SSH then
active_mode = mode[10]
elseif psiph and teste then
active_mode = mode[11]
elseif teste and proxy then
active_mode = mode[12]
else
active_mode = "";
end

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "*."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")
local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.") 
local psiph = string.match(content, '[%S]+FRONTED')
local psi = string.match(content, '%FRONTED.-[%w]+[%S][%w]+') 
local server = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 
local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"
local sni = string.match(content, "[%w%.-]+:%d%d+[^ ]-\0([%w%.-]-%.[%w.-]-)\0") 
local versi = string.match(content, "645") or "645"
local xX = os.date("%d/%m/%Y %I:%M:%S")

local result = {
    [1] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ‡ğ¨ğ¬ğ­ : ",
    ['DATA'] = host
    },
    [2] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğğ¨ğ«ğ­ : ",
    ['DATA'] = port
    },
    [3] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ”ğ¬ğğ« : ",
    ['DATA'] = hostt
    },
    [4] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğğšğ¬ğ¬ : ",
    ['DATA'] = pas
    },
    [5] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğğšğ²ğ¥ğ¨ğšğ : ",
    ['DATA'] = teste
    },
    [6] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğğ«ğ¨ğ±ğ² : ",
    ['DATA'] = proxy
    },
	[7] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğğ©ğğ§ğ•ğğ : ",
    ['DATA'] = testedd
    },
    [8] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ’ğ’ğ‡ : ",
    ['DATA'] = SSH
    },
    [9] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ’ğ’ğ‹ : ",
    ['DATA'] = sni
    },
    [10] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ•ğŸğ«ğšğ² : ",
    ['DATA'] = testeddd
    },
    [11] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğğ¬ğ¢ğ©ğ¡ğ¨ğ§ ğ€ğ®ğ­ğ¡ğ¨ğ«ğ¢ğ³ğšğ­ğ¢ğ¨ğ§",
    ['DATA'] = psiph
    },
    [12] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğğ¬ğ¢ğ©ğ¡ğ¨ğ§ ğğ«ğ¨ğ­ğ¨ğœğ¨ğ¥",
    ['DATA'] = psi
    },
--    [13] = {
--    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ•ğğ«ğ¬ğ¢ğ¨ğ§ : ",
--    ['DATA'] = versi
--    },
    [13] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ“ğ¢ğ¦ğ : ",
    ['DATA'] = xX
    },
--    [15] = {
--    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ“ğ®ğ§ğ§ğğ¥ ğ“ğ²ğ©ğ :",
--    ['DATA'] = active_mode
--    },
 
  }
  
      local message = "```makefile\nâ”Œâ”€[' @Shahriar_X_Fahim '] \nâ”Š'â§¼ ğ’®ğ’½ğ’¶ğ’½ğ“‡ğ’¾ğ“‡_ğ’³_â„±ğ’¶ğ’½ğ’¾ğ“‚ â§½'\nâ”‚'â§¼ HTTP CUSTOM â§½'\nâ”œâ”€â”€â”€â•¼[' t.me/Decrypt_VPN_Files ']\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..""..names.."  ' "..value.." ' \n"
           end
            end
        
            message = message.."â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğƒğğœ ğğ² :' @Shahriar_X_Fahim '\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"
        local alert = gg.alert(message, "ğ‚ğğğ˜", "ğ„ğ—ğˆğ“")
        if alert == 1 then
        gg.copyText(message, false)

        elseif alert == 2 then
        end
      io.open('/sdcard/hc.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  os.exit()
  end

-- â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
function Fahim()
  limit = false
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for _FORV_5_ = 1, SizeOrBuffer do
            _rw[_FORV_5_] = {
              address = Address - 1 + _FORV_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for _FORV_5_, _FORV_6_ in ipairs(gg.getValues(_rw)) do
            if _FORV_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", _FORV_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
  end
  
  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end
  
  function hexencode(str)
    return (str:gsub(".", function(char)
      return string.format("%2x", char:byte())
    end
    ))
  end
  
  function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
  end
  
  function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
  end
  
  function save(data)
    local function hexencode_spasi(str)
      return (str:gsub(".", function(char)
          return string.format("%02x ", char:byte())
      end))
    end

    local function checkMatch(key, str)
      result = nil
      
      for index, value in ipairs(key) do
          result = str:match(value)
          if result then 
              break 
          end
      end
      
      return result
    end

    local function strip(s)
      return (s:gsub("^%s*(.-)%s*$", "%1"))
    end

    local function prosesData(data)

      local function findExpDate(tbl)
          local key = {
              "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d",
              "lifeTime"
          } 
          local result = nil
          
          for index_tbl, value_tbl in ipairs(tbl) do
  
              for index_key, value_key in ipairs(key) do
                  
                  if value_tbl:match(value_key) then
                      result = index_tbl
                  end
  
              end
          end
          return result
      end
  
      local function splitString(str, separator)
          local match_1, match_2 = str:match("(.-)"..separator.."(.*)")
          local tbl = {}
  
          no = 1
          while (match_2:match("(.-)"..separator.."(.*)") and no < 100) do
      
              match_1, match_2 = match_2:match("(.-)"..separator.."(.*)")
      
              if hexdecode(match_1):match("[^\x20]+") then
                  table.insert(tbl, strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
              else 
                  table.insert(tbl,"***")
              end
              
              no = no + 1
          end
  
          return tbl
      end
  
      local function fixedConfig(index, tbl)
          local result_fixedConfig = {}
          local beginIndex = index - 4
          local lastIndex = beginIndex + 31
  
          for i = beginIndex, lastIndex do
              table.insert(result_fixedConfig, tbl[i])
          end
  
          return result_fixedConfig
      end
      data = hexencode_spasi(data)
      data = data:gsub("00", "20")
      data = data:gsub("20", "z")
      data = data:gsub("66 61 6c 73 65", "F A L S E")
      data = data:gsub("\x20", "")
      data = data:gsub("\n", "")
      local separator = data:match("FALSE[\x7a]+(.-)[\x7a]+")
      if separator then
      data = data:gsub(separator, "0a56616c647947616e74656e67")
      separator = "0a56616c647947616e74656e67"
      end
      data = data:gsub("z", "20")
      data = data:gsub("FALSE", "66616c7365")

      local result = splitString(data, separator)
      local assemblyPointIndex = findExpDate(result)
      local getConfig = fixedConfig(assemblyPointIndex, result)
  
      return getConfig
    end
    local function getOutput(tbl)
      local cfgRegex = {
        [25] = {
            ["name"] = '[Psiphon]  : ', 
            ["regex"] = "(.*)"
        },
        [33] = {
          ["name"] = '[Psiphon]  : ',
          ["regex"]= "[\x5b]\x22.*]"
        }
 --  
    }
        
                  local message = "âœ¯ HTTP CUSTOM\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
               
      for index, value in ipairs(tbl) do
          
          if cfgRegex[index] and value:match(cfgRegex[index]["regex"]) then
              local namaKonten = cfgRegex[index]["name"]
              local valueRegexKonten = value:match(cfgRegex[index]["regex"])
              message = message..namaKonten.."`"..valueRegexKonten..'`'.."\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
          end
          
      end
     message = message.."\nâ—‡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â—‡\nDec By â” @Shahriar_X_Fahim \nGroup â” t.me/Decrypt_VPN_Files "
      return message
    end
 


    local contentToDecrypt = hexdecode(data)
        contentToDecrypt = prosesData(hexdecode(data))
        local hasil = getOutput(contentToDecrypt)
        io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
        gg.alert(hasil)
        io.open(gg.EXT_STORAGE .. "/psiphon.txt", "w"):write(hasil)
        gg.copyText(hasil, false)
        gg.toast("âœ“ Success Copy To Clipboard..!!", true)
    end
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setSpeed(20.0)
  gg.searchNumber(":GET / HTTP/", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("Method GET")
    hc_method2 = true
  end
  if hc_method2 then
    gg.searchNumber("Host: ", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("Host:")
      hc_method3 = true
    end
  end
  if hc_method3 then
    gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("inbounds")
      hc_method4 = true
    end
  end
  if hc_method4 then
    gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("[crlf]")
      hc_method5 = true
    end
  end
  if hc_method5 then
    gg.searchNumber("Upgrade: websocket", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("Upgrade: websocket")
      hc_method6 = true
    end
  end
  if hc_method6 then
    gg.searchNumber(":GET wss:", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("GET wss")
      hc_method7 = true
    end
  end
  if hc_method7 then
    gg.searchNumber(":[splitPsiphon][splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("splitPsiphon")
      hc_method8 = true
    end
  end
    if hc_method8 then
    gg.searchNumber(":[splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("[ey")
      hc_method9 = true
    end
  end
  if hc_method9 then
    gg.searchNumber(":b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("splitPsiphon")
      hc_method10 = true
    end
  end
 if hc_10 then
    limit = false
    gg.searchNumber("h 23 20 43 6F 6E 66 69 67 20 66 6F 72 20 4F 70 65 6E 56 50 4E 20 32 2E 78", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("config for OpenVPN 2x")
      hc_11 = true
    end
  end

  if hc_method11 then
    print("All methods failed")
    print('Hubungi Nathan!')
    os.exit()
  end
  local r = gg.getResults(12)
  if limit == false then
    r[1].address = r[1].address - 5376
  end
  readedMem = rwmem(r[1].address, 15000)
  save(readedMem)
  gg.clearResults()
  os.exit()
end

function UDPNEW()
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/udp.txt", "w"):write(hexdecode(data))
    
    gg.toast("Found âœ…")
end

 gg.clearResults()
  gg.setRanges(gg.REGION_ANONYMOUS)
  gg.setSpeed(20.0)
  gg.setVisible(false)
 gg.searchNumber(':{"configType":', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0) 
  local r = gg.getResults(1)
  if #r < 1 then
    
    hc_2 = true
    end 
   if hc_2 then
     gg.searchNumber("h 22 55 73 65 72", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      hc_3 = true
    end
  end
  if hc_3 then
     gg.searchNumber("h 22 73 65 72 76 65 72 22 3A 20 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      hc_4 = true
    end
  end
      
  if hc_4 then
local readedMem = ""
local continue, udpcheck = true, true
if #r < 1 then
udpcheck = false
gg.toast("ğ’ğ®ğ©ğğ« ğ…ğšğ¬ğ­ ğğ«ğğ¦ğ¢ğ®ğ¦ ğ‹ğ®ğš ğ’ğœğ«ğ¢ğ©ğ­\n ğğ² â€”ÍÍŸÍâ›¦ğ“†©ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—ºğ“†ªãƒ¡")
HTTPCustom()
if res == 2 then
continue = false
os.exit()
end
end
  end

local r = gg.getResults(1)
  if limit == false then
    r[1].address = r[1].address - 100
  end
  readedMem = rwmem(r[1].address, 900)
  save(readedMem)
  gg.clearResults()
  
function udpSF()
function udp()

    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find('"' .. palavraChave .. '"')

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim
                
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local textoCapturado = conteudo:sub(inicioJSON, fimJSON)

               
                gg.alert(label .. ": " .. textoCapturado)
                gg.copyText(textoCapturado, false)
                local arquivoSaida = io.open("/sdcard/udp.txt", "a")

                if not arquivoSaida then
                    print("")
                    return
                end

                arquivoSaida:write(label .. ": " .. textoCapturado .. "\n\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    local function obterEntradaSSH()
        local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})

        if texto == nil then
            os.exit()
        end

        return texto[1]
    end

    local function salvarTextoEmArquivo(texto, caminhoArquivo)
        if texto == nil or texto == "" then
            return nil, "Texto invÃ¡lido"
        end

        if caminhoArquivo == nil or caminhoArquivo == "" then
            return nil, "Caminho de arquivo invÃ¡lido"
        end

        local arquivo = io.open(caminhoArquivo, "w")
        if arquivo == nil then
            return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
        end

        arquivo:write(texto)
        arquivo:close()

        return true
    end

    local function lerTextoDeArquivo(caminhoArquivo)
        if caminhoArquivo == nil or caminhoArquivo == "" then
            return nil, "Caminho de arquivo invÃ¡lido"
        end

        local arquivo = io.open(caminhoArquivo, "r")
        if arquivo == nil then
            return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
        end

        local conteudo = arquivo:read("*all")
        arquivo:close()

        if conteudo == nil then
            return nil, "NÃ£o foi possÃ­vel ler o conteÃºdo do arquivo"
        end

        return conteudo
    end

    local function exibirEInserir(arquivoSaida, label, texto)
        
        local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

        if not sucesso then
            print("Erro ao escrever no arquivo de saÃ­da: " .. erro)
        end
    end
        
    function udpxx()
        local caminhoArquivoEntrada = "/sdcard/udp.txt"
        local caminhoArquivoSaida = "/sdcard/udp.txt"

        local arquivoEntrada = io.open(caminhoArquivoEntrada, "r")

        if not arquivoEntrada then
            print("Falha ao abrir o arquivo de entrada: " .. caminhoArquivoEntrada)
            return 
        end

        local conteudoEntrada = arquivoEntrada:read("*all")
        arquivoEntrada:close()

        if conteudoEntrada and conteudoEntrada ~= "" then
            local hcRegex = {}
            hcRegex["Udp"] = '"user"%s*:%s*"([^"]+)"%s*,%s*"auth"%s*:%s*"([^"]+)"'

            function bitwise(val1, val2)
                return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
            end

            function extract(data, iv)
                if type(data) ~= "string" then
                    return nil, nil
                end

                local new_data = ""
                for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
                    local ivNum = tonumber(iv)
                    if not ivNum then
                        return nil, nil
                    end

                    local val1Num = tonumber(val1)
                    local val2Num = tonumber(val2)

                    if not val1Num or not val2Num then
                        return nil, nil
                    end

                    local val11 = val1Num - ivNum
                    local val22 = val2Num - ivNum

                    local val3 = ((val11 // (2 ^ val22)) % 256)
                    local car = string.char(val3)
                    new_data = new_data .. car
                end

                if verificaString(new_data) then
                    return new_data
                else
                    new_data = ""
                    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
                        car = bitwise(val1, val2)
                        new_data = new_data .. car
                    end
                    return new_data
                end
            end

            function verificaString(str)
                for i = 1, #str do
                    local char = str:sub(i, i)
                    local ascii = string.byte(char)
                    if (ascii < 32 or ascii > 126) or (ascii > 90 and ascii < 97) then
                        return false
                    end
                end
                return true
            end

            function calculaIv(user, senha)
                if type(user) ~= "string" or type(senha) ~= "string" then
                    return nil, "UsuÃ¡rio e senha devem ser strings"
                end

                local countU = 0
                local countP = 0
                for match in user:gmatch("(-?%d+)%.(-?%d+)") do
                    countU = countU + 1
                end
                for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
                    countP = countP + 1
                end

                return countU, countP
            end

            function dec_user_pass(user, userIv, pasw, passIv)
                return extract(user, userIv), extract(pasw, passIv)
            end

            local udpUserEnc, udpPassEnc = string.match(conteudoEntrada, hcRegex["Udp"])

            if udpUserEnc and udpPassEnc then
                local userIv, passIv = calculaIv(udpUserEnc, udpPassEnc)

                if userIv and passIv then
                    local udpUser, udpPass = dec_user_pass(udpUserEnc, userIv, udpPassEnc, passIv)

                    if udpUser and udpPass then
                        
                        local resultadoDecodificado = "Username: " .. udpUser .. "\nPassword: " .. udpPass
                        conteudoEntrada = string.gsub(conteudoEntrada, 'user": "([%d-.]+)"', 'user": "' .. udpUser .. '"')
                        conteudoEntrada = string.gsub(conteudoEntrada, 'auth": "([%d-.]+)"', 'auth": "' .. udpPass .. '"')

                        conteudoEntrada = removeNullBytes(conteudoEntrada)

                        local arquivoSaida = io.open(caminhoArquivoSaida, "w")
                        
                        if not arquivoSaida then
                            
                        else
                            arquivoSaida:write(conteudoEntrada)
                            arquivoSaida:close()
                   
                        end
                    else
                        
                    end
                else
                    
                end
            else
                print("")

            end
        end
    end

    
    udpxx()
end

udp()
end

udpSF()

local f = io.open("/sdcard/udp.txt", "r")
local content = f:read("*all")
f:close()

local f = io.open("/sdcard/udp.txt", "w")
f:write(content)
f:close()

local start = "```makefile\nâ”Œâ”€[' @Shahriar_X_Fahim '] \nâ”Š'â§¼ ğ’®ğ’½ğ’¶ğ’½ğ“‡ğ’¾ğ“‡_ğ’³_â„±ğ’¶ğ’½ğ’¾ğ“‚ â§½'\nâ”‚â§¼ ğ”ğƒğ ğ‚ğ”ğ’ğ“ğğŒ â§½\nâ”œâ”€â”€â”€â•¼[' t.me/Decrypt_VPN_Files ']\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
local final = ""

content = string.gsub(content, '"server": "', '",    "server": "')

local app = content:match('udp') or 'udp'
local server_udp = content:match('"server": "(.-)"')
local user_udp = content:match('"user": "(.-)"')
local auth_udp = content:match('"auth": "(%w+)"')
local sni_udp = content:match('"sni": "(.-)"')
local rx_udp = content:match('"rx_receive": (%d+)')
local tx_udp = content:match('"tx_transfer": (%d+)')
local stream_udp = content:match('"stream_buffer": (%d+)')
local receive_udp = content:match('"receive_buffer": (%d+)')
local insicure_udp = content:match('"insecure": (%w+)')
local socks_udp = content:match('"socks5": (%d+)') or "{"
local listen_udp = content:match('"listen": "(.-)"')

local message = start

local function addKey(label, value)
  if value and value ~= "" then
    message = message .. '' .. label .. '' .. value .. '\n'
  end
end

addKey("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ’ğ§ğ¢: ", sni_udp)
addKey("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ‘ğ±_ğ«ğğœğğ¢ğ¯ğ: ", rx_udp)
addKey("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ“ğ±_ğ­ğ«ğšğ§ğ¬ğŸğğ«: ", tx_udp)
addKey("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ’ğ­ğ«ğğšğ¦_ğ›ğ®ğŸğŸğğ«: ", stream_udp)
addKey("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ‘ğğœğğ¢ğ¯ğ_ğ›ğ®ğŸğŸğğ«: ", receive_udp)
addKey("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ‹ğ¢ğ¬ğ­ğğ§: ", listen_udp)
addKey("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ€ğ®ğ­ğ¡: ' ", server_udp ..'@'.. user_udp ..':'.. auth_udp .."'\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğƒğğœ ğğ² : @Shahriar_X_Fahim\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```")

if message ~= "" then
  message = message .. final
  gg.alert(message, 'ğ‚ğğğ˜ ğ”ğƒğ')
  gg.copyText(message, false)
end

local f = io.open("/sdcard/udp.txt", "w")
f:write(message)

f:close()
gg.setVisible(false)
end
  
function V2RAY()

limit = false
function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  
  if type(SizeOrBuffer) == "number" then
    _ = ""
    
    for SRD1_5_ = 1, SizeOrBuffer do
      _rw[SRD1_5_] = {
        address = Address - 1 + SRD1_5_,
        flags = gg.TYPE_BYTE
      }
    end
    
    for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
      if SRD1_6_.value == 0 and limit == true then
        return _
      end
      
      _ = _ .. string.format("%02X", SRD1_6_.value & 255)
    end
    
    return _
  end
  
  Byte = {}
  SizeOrBuffer = SizeOrBuffer:gsub("[^%w%s%p]+", "")
  
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end)
  
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
  io.open("/sdcard/e-V2ray.txt", "w"):write(data)
end

limit = true
gg.setVisible(false)
gg.processPause()
gg.clearResults()
gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_PPSSPP | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_BAD)
  gg.setSpeed(20.0)
  gg.setVisible(false)
  gg.searchNumber("h 7B 0A 09 09 22 69 6E 62 6F 75 6E 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("inbounds")
    hc_2 = true
  end
  if hc_2 then 
    gg.searchNumber("h 7B 0A 09 09 22 64 6E 73 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_3 = true
    end
  end
  if hc_3 then
    gg.searchNumber("h 20 22 64 6e 73 22 3a 20 7b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_4 = true
    end
  end
  if hc_4 then
    gg.searchNumber("h 7B 0A 09 09 09 09 09 09 09 09 09 09 09 09 22 61 64 64 72 65 73 73 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("address")
      hc_5 = true
    end
  end
  if hc_5 then
    gg.searchNumber("h 22 6c 6f 67 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_6 = true
    end
  end
  if hc_6 then
    gg.searchNumber("h 22 6f 75 74 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("outbounds")
      hc_7 = true
    end
  end
  
  
  
  if hc_7 then
gg.searchNumber("h 22 69 6e 62 6f 75 6e 64 73 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_8 = true
    end
  end  
  
   if hc_8 then
gg.searchNumber("h 22 64 6e 73 22 3a 20", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_9 = true
    end
  end 
  
    if hc_9 then
gg.searchNumber("h 22 64 6e 73 22 3a 20", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_10 = true
    end
  end  
    if hc_10 then
gg.searchNumber("h 22 69 6e 62 6f 75 6e 64 73 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_11 = true
    end
  end    
  if hc_11 then
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_12 = true
    end
  end      
  if hc_12 then
gg.searchNumber(':{\n		"dns":', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_13 = true
    end
  end       
  
   
    
     
       
  
  
  
      if hc_13 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
    print("all metode Failed\n")
    os.exit()        
        
    end
    if hc_13 then
    gg.alert("Decryption failed use Clear/Reset Config and reimport the file")
    gg.processResume()
    gg.toast("  ğƒğğœğ«ğ²ğ©ğ­ ğ…ğšğ¢ğ¥ğğ!  ")
    print("DONE")
   os.exit()
  end
  local r = gg.getResults(4)
    if limit == false then
        r[1].address = r[1].address - 200
        end
    
    readedMem = rwmem(r[1].address, 5000)
  save(hexdecode(readedMem))
  gg.processResume()
  gg.clearResults()

local f = io.open("/sdcard/e-V2ray.txt", "r")
local content = f:read("*all")
f:close()

content = "```json\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚ [ãƒ ] ğ—©ğŸ®ğ—¥ğ—”ğ—¬ ğ—”ğ—Ÿğ—Ÿ ğ—ğ—¦ğ—¢ğ—¡ â–¼\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚ [ãƒ ] ğ—–ğ—¢ğ——ğ—˜ ğ—•ğ—¬: t.me/Decrypt_VPN_Files\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`" .. content .. "`\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚ [ãƒ ] ğ——ğ—²ğ—°ğ—¿ğ˜†ğ—½ğ˜ ğ—•ğ˜†: @Shahriar_X_Fahim\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"

local f = io.open("/sdcard/e-V2ray.txt", "w")
f:write(content)
f:close()
gg.alert(content, 'COPY AND EXIT')
gg.copyText(content, false)
gg.toast("â™  ğƒğğœğ«ğ²ğ©ğ­ ğ’ğ®ğœğœğğ¬ğ¬!  â™")
print(" DONE ")
end


function SSCCustom()
  limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_ANONYMOUS)
gg.setVisible(false)
gg.setSpeed(20.0)
gg.searchNumber(":[host]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then   
    hc_method2 = true
end
if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(':[splitPsiphon', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method10 = true
end
end
if hc_method10 then
gg.alert("KEYWORD NOT FOUND")
os.exit()
end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto invÃ¡lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "NÃ£o foi possÃ­vel ler o conteÃºdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/decrypt.txt"

    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saÃ­da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)

    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "UsuÃ¡rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saÃ­da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end


local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    exibirEInserir(arquivoSaida, " ", saida)
    
    arquivoSaida:close()
end    

processarSSHx()

function payloadSF()
function payload()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function payloadx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
        end
    end

    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    payloadx()
end

payload()
end

payloadSF()

function ovpnSF()
function ovpn()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function ovpnx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end


  local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    ovpnx()
end

ovpn()
end

ovpnSF()

function v2raySF()
function v2ray()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

   
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] ğ•ğŸğ‘ğšğ²"

    
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    v2rayx()
end

v2ray()
end

v2raySF()

local mode = {
"SSH â” Payload & V2ray",
"V2ray",
"SSH â” Payload",
"SSL â” SSH â” Direct",
"OpenVPN â” Payload",
"Payload â” OpenVPN",
"OpenVPN",
"V2ray â” Payload",
"SSH â” Direct",
"SSH â” Payload",
"Psiphon â” Payload",
"Payload",
}
local active_mode = ""
if pas and teste and proxy and testeddd then
active_mode = mode[1]
elseif testeddd then
active_mode = mode[2]
elseif host and teste then
active_mode = mode[3]
elseif sni and pas then
active_mode = mode[4]
elseif testedd then
active_mode = mode[5]
elseif teste and proxy and testedd then
active_mode = mode[6]
elseif testedd then
active_mode = mode[7]
elseif testeddd and teste then
active_mode = mode[8]
elseif pas then
active_mode = mode[9]
elseif SSH then
active_mode = mode[10]
elseif psiph and teste then
active_mode = mode[11]
elseif teste and proxy then
active_mode = mode[12]
else
active_mode = "";
end

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "*."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")
local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.") 
local psiph = string.match(content, '[%S]+FRONTED')
local psi = string.match(content, '%FRONTED.-[%w]+[%S][%w]+') 
local server = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 
local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"
local sni = string.match(content, "[%w%.-]+:%d%d+[^ ]-\0([%w%.-]-%.[%w.-]-)\0") 
local versi = string.match(content, "645") or "645"
local xX = os.date("%d/%m/%Y %I:%M:%S")

local result = {
   [1] = {
   ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™ğ™ğ™ƒ ğ˜¼ğ™™ğ™™ğ™§ğ™šğ™¨ğ™¨ : ",
    ['DATA'] = host
    },
    [2] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™‹ğ™¤ğ™§ğ™© : ",
    ['DATA'] = port
    },
    [3] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™ğ™¨ğ™šğ™§ğ™£ğ™–ğ™¢ğ™š : ",
    ['DATA'] = hostt
    },
    [4] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™‹ğ™–ğ™¨ğ™¨ğ™¬ğ™¤ğ™§ğ™™ : ",
    ['DATA'] = pas
    },
    [5] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ™‹ğ™–ğ™®ğ™¡ğ™¤ğ™–ğ™™ : ",
    ['DATA'] = teste
    },
    [6] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ™‹ğ™§ğ™¤ğ™­ğ™® : ",
    ['DATA'] = proxy
    },
  	[7] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™Šğ™‘ğ™‹ğ™‰ : ",
    ['DATA'] = testedd
    },
    [8] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ™ğ™ğ™ƒ : ",
    ['DATA'] = SSH
    },
    [9] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ™ğ™ğ™‡/ğ™ğ™‰ğ™„ : ",
    ['DATA'] = sni
    },
    [10] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™‘2ğ™ğ˜¼ğ™” : ",
    ['DATA'] = testeddd
    },
    [11] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™‹ğ™¨ğ™ğ™¥ğ™ğ™¤ğ™£ ğ˜¼ğ™ªğ™©ğ™",
    ['DATA'] = psiph
    },
    [12] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™‹ğ™¨ğ™ğ™¥ğ™ğ™¤ğ™£ ğ™‹ğ™§ğ™¤ğ™©ğ™¤ğ™˜ğ™¤ğ™¡",
    ['DATA'] = psi
    },
--    [13] = {
--    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ˜¼ğ™¥ğ™¥ ğ™‘ğ™šğ™§ğ™¨ğ™ğ™¤ğ™£ : ",
--    ['DATA'] = versi
--    },
--    [14] = {
--    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™ğ™„ğ™ˆğ™€ : ",
--    ['DATA'] = xX
--    },
--    [15] = {
--    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”ƒ[â–] ğ™ğ™ªğ™£ğ™£ğ™šğ™¡ ğ™ğ™®ğ™¥ğ™š :",
--    ['DATA'] = active_mode
--    },
 
  }
  
      local message = "```makefile\nâ”Œâ”€[ @Shahriar_X_Fahim ] \nâ”Šâ§¼ ğ’®ğ’½ğ’¶ğ’½ğ“‡ğ’¾ğ“‡_ğ’³_â„±ğ’¶ğ’½ğ’¾ğ“‚ â§½\nâ”‚â§¼ SSC CUSTOM â§½\nâ”œâ”€â”€â”€â•¼[ t.me/Decrypt_VPN_Files ]\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..""..names.."  ' "..value.." ' \n"
           end
            end
        
            message = message.."â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ˜¿ğ™šğ™˜ ğ˜½ğ™® : @Shahriar_X_Fahim\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"
        local alert = gg.alert(message, "ğ˜¾ğ™Šğ™‹ğ™”", "ğ˜¾ğ˜¼ğ™‰ğ˜¾ğ™€ğ™‡")
        if alert == 1 then
        gg.copyText(message, false)

        elseif alert == 2 then
        end
      io.open('/sdcard/hc.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  os.exit()
  end

function NpvtSSH()
limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
--ProgressBar = "éˆºæˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆº?";for x = 1,15,1 do gg.sleep(40) ---ProgressBar = ProgressBar:gsub("éˆ»?","éˆ»?",1);gg.toast(ProgressBar) end
    io.open(gg.EXT_STORAGE .. "/HTTP_CUSTOM.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP)
gg.setSpeed(20.0)
---gg.makeRequest("https://raw.githubusercontent.com/EstebanZxx/Forbidden/main/KEY-ACCESS") key= W4nn4P14yW1thKyy ğŸ¸ğŸ¸
gg.setVisible(false)
--gg.setVisible(false)
gg.searchNumber(":[lf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method2 = true
end

if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(":444@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method10 = true
end
end
if hc_method10 then
    gg.alert("No matching keywords!")
    os.exit()
end

local r = gg.getResults(100)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/HTTP_CUSTOM.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/HTTP_CUSTOM.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto invè°©lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invè°©lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "NèŒ«o foi possé“†vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invè°©lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "NèŒ«o foi possé“†vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "NèŒ«o foi possé“†vel ler o conteç…¤do do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/HTTP_CUSTOM.txt"

    -- Abre o arquivo no modo de escrita no diretè´¸rio do script
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        -- Construir a string com os valores a serem salvos
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saé“†da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depuraè½èŒ«o
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usuè°©rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saé“†da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt"
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    -- Criar ou abrir o arquivo de saé“†da
    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end

    -- Concatenar os resultados
local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
sshResults = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    -- Exibir e salvar os resultados
    exibirEInserir(arquivoSaida, " ", saida)
    
-- Fechar o arquivo de saé“†da
    arquivoSaida:close()
end    

processarSSHx()

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "***."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")

local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.")

function payloadx9()
function payload()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end
    
    
        local function payloadx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
    ---        teste = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    payloadx()
end

payload()
end

payloadx9()

function ovpnx9()
function ovpn()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function ovpnx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
---        testedd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    ovpnx()
end

ovpn()
end

ovpnx9()

function v2rayx9()
function v2ray()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()
                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function v2rayx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] é¥¾æ‚¤é¥¾ç…‡é¥¾æ‚œé¥¾æ‚®é¥¾æƒ’"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
 ---       testeddd= "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    v2rayx()
end

v2ray()
end

v2rayx9()

function pythonx9()
function python()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedddd = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function pythonx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsPython = {'"ey', 'FRONTED-'}
    local labelPython = ""

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouPython = tentarEncontrarPalavrasChave(conteudo, keywordsPython, labelPython)

    if encontrouPython then
        print("")
    else
  --     testedddd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    pythonx()
end

python()
end

pythonx9()

local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 

local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"

local sni = string.match(content, "[%w%.-]+:%d%d+[^é¦ƒæ§‡]-\0([%w%.-]-%.[%w.-]-)\0") 

local ns  = string.match(content, "false") or "false"

local pubkey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65][%w.-]+.") 

local psiphon = string.match(content, "[\x5b]\x22.*]") or false

local versi = string.match(content, "645") or "645"

local xX = os.date("%d/%m/%Y %I:%M:%S")

--local xX = os.date("%I:%M %p")

function keyx9()
function key()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                pub = (texto) 
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function keyx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"b22", "bc2c"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
     ---       pub = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    keyx()
end

key()
end

keyx9()

function slowdnsx9()
function slowdns()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                name = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function slowdnsx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsSlowdns = {"ns", "n%s-"}
        local labelSlowdns = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouSlowdns = tentarEncontrarPalavrasChave(conteudo, keywordsSlowdns, labelSlowdns)

        if encontrouSlowdns then
            print("")
        else
        --    name = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    slowdnsx()
end

slowdns()
end

slowdnsx9()
local SlowDnsServer = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local PubKey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65]+")
local SSLSNI = string.match(content, "[%w]-%.[%w]-%.[%w]-")

local result = {
    [1] = {
    ['NAME'] = "\nâ”‚[ãƒ ] ğ‰ğ¬ğ¨ğ§ ğ…ğ¨ğ«ğ¦ğšğ­ğ : ",
    ['DATA'] = teste
    },
   	[2] = {
    ['NAME'] = "\nâ”‚[ãƒ ] ğğ«ğ¨ğ±ğ² : ",
    ['DATA'] = proxy
    },
--    [3] = {
--    ['NAME'] = "\nâ”‚[ãƒ ] ğ’ğ’ğ‡ : ",
--    ['DATA'] = sshResults
--    },
    [3] = {
    ['NAME'] = "\nâ”‚[ãƒ ] ğ’ğ’ğ‹ : ",
    ['DATA'] = SSLSNI
    },
--    [5] = {
--    ['NAME'] = "\nâ”‚[ãƒ ] ğ•2ğ‘ğ€ğ˜ : ",
--    ['DATA'] = testeddd
--    },
--    [6] = {
--    ['NAME'] = "\nâ”‚[ãƒ ] ğğ’ğˆğğ‡ğğ : ",
--    ['DATA'] = testedddd
--    },
--    [7] = {
--    ['NAME'] = "\nâ”‚[ãƒ ] ğğ•ğğ : ",
--    ['DATA'] = testedd
--    },

  }
  
      local message = "```rust\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[ãƒ ] ğ‚ğ¨ğğ ğğ² : @Shahriar_X_Fahim\nâ”‚[ãƒ ] ğ†ğ«ğ¨ğ®ğ© : t.me/Decrypt_VPN_Files"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message.."\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"..names.." ' "..value.." ' "
           end
            end
         
            message = message.."\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[ãƒ ] ğƒğğœğ«ğ²ğ©ğ­ ğğ² : @Shahriar_X_Fahim\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"
        local alert = gg.alert(message, "ğ’ğ€ğ•ğ„", "ğ‚ğ€ğğ‚ğ„ğ‹")
        if alert == 1 then
        gg.copyText(message, false)
        gg.toast("Copied To Clipboard")
        elseif alert == 2 then
        end
      io.open('/sdcard/HTTP_CUSTOM.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  end                



function sip()
gg.setVisible(true)
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for SRD1_5_ = 1, SizeOrBuffer do
            _rw[SRD1_5_] = {
              address = Address - 1 + SRD1_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
            if SRD1_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", SRD1_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
end

  

  function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(data)
  end

  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end

  gg.clearResults()
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_PPSSPP | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_BAD)
  gg.setSpeed(20.0)
  gg.setVisible(false)
  gg.searchNumber("h 6c 69 73 74 65 6e 50 6f 72 74 71 00 7e 00 01 4c 00 06", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    
    sip_2 = true
  end
  if sip_2 then
    gg.searchNumber("h6E6577746F6F6C73776F726B732E636F6D2E736F636B7369702E7574696C732E536572536F636B73495068", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_3 = true
    end
  end
  if sip_3 then
    gg.searchNumber("h 55 70 67 72 61 64 65 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_4 = true
    end
  end
  if sip_4 then
    gg.searchNumber("h 3A 38 30 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_5 = true
    end
  end
  if sip_5 then
    limit = false
    gg.searchNumber("h 7B 0A 09 09 22 69 6E 62 6F 75 6E 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_6 = true
    end
  end
  if sip_6 then
    limit = false
    gg.searchNumber("h 73 70 65 65 64 79 73 73 68 2e", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_7 = true
    end
  end
  if sip_7 then
    limit = false
    gg.searchNumber("h 3A 35 33 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_8 = true
    end
  end
  if sip_8 then
    limit = false
    gg.searchNumber("h 47 45 54 20 77", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_9 = true
    end
  end
  if sip_9 then
    limit = false
    gg.searchNumber("h 5b 63 72 6c 66 5d 48 6f 73 74 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_10 = true
    end
  end
  if sip_10 then
    limit = false
    gg.searchNumber("h 48 6f 73 74 3a 5b 72 6f 74 61 74 65 3d", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_11 = true
    end
  end
  if sip_11 then
    limit = false
    gg.searchNumber("h 3A 34 34 33 40", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      
      sip_12 = true
    end
  end
  if sip_12 then
    gg.toast("ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—º")
    print("Close Socksip, reopen after 3secs and try again \n\n")
    os.exit()
  end
  local r = gg.getResults(9000)
  if limit == false then
    r[1].address = r[1].address - 8192
  end
  _G.readedMem = rwmem(r[1].address, 9000)
  save(hexdecode(readedMem))
  
  print("âœ“ Saved In: /sdcard/decrypt.txt")
  gg.clearResults()
  
  
    
  local file = io.open("/sdcard/decrypt.txt", 'rb')
  local content = file:read(9000)
  file:close()
  local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
  local sshcontent = sshfile:read(3400)
  sshfile:close()

local serverPayload = string.match(sshcontent, "GET%s.*TCP") or string.match(content, "POST%s.*TCP")or string.match(content, "CONNECT%s.*TCP")or string.match(content, "PUT%s.*TCP")or string.match(content, "BMOVE%s.*TCP") or string.match(content, "[A-Z]%sHTTP/.*TCP") or string.match(content, "HTTP/.*TCP") or string.match(content, "HTTP/.*%[lf%]") or string.match(content, "HTTP/.*%[crlf%]") or "___"
if not string.match(sshcontent, "GET%s.*TCP") or not string.match(sshcontent, "POST%s.*TCP") or not string.match(sshcontent, "CONNECT%s.*TCP") or string.match(sshcontent, "PUT%s.*TCP")then
local payload = {}
for i = 1, #serverPayload - 6 do
table.insert(payload, string.sub(serverPayload, i, i))
end
serverPayload = table.concat(payload,"")
else end

local SSH = string.match(sshcontent, "[%d%.%w.-]+:[%d]+@[%w%.-]+:[%w%.-]+")  or "_"
local shs = {}
for i = 1, #SSH - 1 do
table.insert(shs, SSH:sub(i,i))
end
SSH = table.concat(shs, "")


local udpserver = string.match(sshcontent, "%d+%.%d+%.%d+%.%d+t") or ""
udpserver = udpserver:gsub('t', "")

local websocket = string.match(content, "[%a%d]+%.[%w+%a]+%.xyzt  ") or ""
websocket = websocket:gsub("t  q ~", "")

local sshusern = string.match(content, "@[%w+%.-]+") or false

local udpuser = sshcontent:match('t %c[%w%.-]+-%w+') or string.match(sshcontent, "[%w%.-]+-%w+")  or "_"
local us = {}
for i = 1, #udpuser - 1 do
table.insert(us, udpuser:sub(i,i))
udpusern = table.concat(us, "")
udpusern = udpusern:gsub('t%c','')
udpusern = udpusern:gsub("%c","")
end
udpusern = udpusern or ""

local username2 = string.match(sshcontent, "t %w+q")  or "___"

udpass = string.match(sshcontent, "%Ct [%c%s]+%w+t [%c]%d") or sshcontent:match("zt [%c%s]+%w+t [%c]%d") or sshcontent:match("t [%c%s]+%w+t [%c]%d") or "___"
local sp1 = {}
for i = 4, #udpass -4 do
table.insert(sp1, udpass:sub(i,i))
end
local udpass = table.concat(sp1,"")
udpass = udpass:gsub("%c","")
udpass = udpass:gsub("%s","")

local suser = {}
sshusername = string.match(sshcontent, "t [%c]+%w+t  q ") or "___"
for i = 4, #sshusername - 5 do
table.insert(suser, sshusername:sub(i,i))
end
sshusername = table.concat(suser,"")
local sshusername2 = SSH:match("@([%w%-]+):") or false
local suser2 = {}
for i = 2, #sshusername - 1 do
table.insert(suser2, sshusername2:sub(i,i))
end
sshusername2 = table.concat(suser2, "")
local spass = {}
sshpassword = string.match(sshcontent, "t [%c]+%w+t") or "___"
for i = 4, #sshpassword - 1 do
table.insert(spass, sshpassword:sub(i,i))
end
sshpassword = table.concat(spass,"")

local sshproxy = string.match(sshcontent, "[%w%.]+:[%d]+t") or ""
sshproxy = sshproxy:gsub('t','')

local proxy = string.match(content, "%d+%.%d+%.%d+%.%d+:8080") or content:match('%d+%.%d+%.%d+%.%d+:80') or string.match(content, "%d+%.%d+%.%d+%.%d+:443")  or string.match(content, "%d+%.%d+%.%d+%.%d+:3128")

local nameserver = string.match(content,"n%w+%d?%.fibertunnel.xyzt") or  string.match(content, "nsam%d?[%w.-]+") or string.match(content, "n%w+%d?[%w.-]+") or "_"
local ns = {}
for i = 1, #nameserver - 1 do
table.insert(ns, nameserver:sub(i,i))
end 
local nameserver = table.concat(ns,"")

local serverLocation = string.match(content,"Amsterdam EU") or string.match(content,"France EU") or string.match(content,"USA %d")

local serverProtocol = string.match(content, "%u+,%u+,%u+,%u+")

local serverDNS = string.match(content, "%d+%.%d+%.%d+%.%d+:53") or ""

local hostws = string.match(content,"%U%U%d?%.fibertunnel.xyz") or string.match(content, "%A+%.%A+%.xyz") or string.match(content,"br1.fibertunnel.xyz") or string.match(content,"br2.fibertunnel.xyz") or string.match(content,"gr1.fibertunnel.xyz") or string.match(content,"ca1.fibertunnel.xyz") or string.match(content,"uk1.fibertunnel.xyz") or string.match(content,"uk2.fibertunnel.xyz") or string.match(content,"fr1.fibertunnel.xyz") or string.match(content,"fr2.fibertunnel.xyz") or string.match(content,"am1.fibertunnel.xyz")

local pubkey = string.match(content, "@[%d%U]+a") or ""

local pkey = string.match(pubkey, "[%d%a]+") or ""

local notes = content:match("<.*>.*</[%w%p]+>") or content:match("<[%w%p%s]+>.*</[%w%p]+>")

local sni = content:match("[%w]+%.[%w]+%.[%w]+%.[%w]+t") or content:match("[%w]+%.[%w]+%.[%w]+t") or content:match("[%w]+%.[%w]+t") or "_"
local sn = {}
for i = 1, #sni - 1 do
table.insert(sn, sni:sub(i,i))
end 
sni = table.concat(sn, "")

local key = content:match("[%w][%w%p%a]+=")

local mode = {"Request/Single Tunnel","Custom SSH","Custom UDP","DNS","Custom Websocket",}
local active_mode = ""
if #serverPayload > 10 then
active_mode = mode[1]
elseif #udpserver > 7 and #udpusern > 5 or #udpass > 6 then
active_mode = mode[3]
elseif #SSH > 7 and sshusername > 3 and sshpassword > 3 then
active_mode = mode[2]
elseif #serverDNS > 6 and  #pkey > 10 then
active_mode = mode[4]
elseif  #sni > 6 and #serverPayload < 10 and #udpserver < 6 then
active_mode = mode[5]
else
active_mode = "";
end

local result = {
	[1] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] sock_mode",
    ['DATA'] = active_mode
  },
  [2] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] payload",
    ['DATA'] = serverPayload
  },
  [3] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] server_udp",
    ['DATA'] = udpserver 
  },
  [6] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] server",
    ['DATA'] = SSH
  },
  [4] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] username_udp",
    ['DATA'] = udpusern
  },
  [5] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] password_udp",
    ['DATA'] = udpass
  },
    [7] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] username",
    ['DATA'] = sshusername
  },
    [8] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] password",
    ['DATA'] = sshpassword
  },
  [9] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] proxy",
    ['DATA'] = sshproxy
  },
  [10] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] proxy_port",
    ['DATA'] = proxy
  },
  [11] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] host_websocket",
    ['DATA'] = hostws or websocket
  },
  [12] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] location", 
    ['DATA'] = serverLocation
  },
  [13] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] protocol", 
    ['DATA']= serverProtocol
  },
  [14] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] ssl_sni",
     ['DATA'] = sni
    },
  [15] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] server_dn", 
    ['DATA'] = serverDNS
  },
  [16] = {  
["NAME"] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] name_server",   
 ["DATA"] = nameserver
},
[17] = { 
["NAME"] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] public_key", 
['DATA'] = pkey
},
 [19] = { 
["NAME"] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] notes" , 
['DATA'] = notes
},
[18] = { 
["NAME"] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ®] server_key" , 
['DATA'] = key
},
 
  }
  
      local message = "```makefile\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚ğ’ğğ‚ğŠğ’ğˆğ (ğ’ğˆğ)\nâ”‚ğ†ğ«ğ¨ğ®ğ©: t.me/Decrypt_VPN_Files\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..names.." : ' "..value.." '\n"
           end
            end

            message = message.."â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚ğƒğğœ ğğ² :' t.me/Shahriar_X_Fahim '\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"
      gg.alert(message, "COPY TO CLIPBOARD")
      io.open('/sdcard/socksip.txt', 'w'):write(message)
      gg.copyText(message, false)
      gg.toast("ğ—¦ğ—µğ—®ğ—µğ—¿ğ—¶ğ—®ğ—¿ ğ—™ğ—®ğ—µğ—¶ğ—º")
    save(hexdecode(readedMem))
  gg.clearResults()
end



function Npvtv2ray()
  limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_PPSSPP | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_BAD)
  gg.setVisible(false)
  gg.setSpeed(20.0)
  gg.searchNumber("h 7B 0A 09 09 22 69 6E 62 6F 75 6E 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("inbounds")
    hc_method2 = true
  end
  if hc_method2 then 
    gg.searchNumber("h 7B 0A 09 09 22 64 6E 73 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("dns")
      hc_method3 = true
    end
  end
  if hc_method3 then
    gg.searchNumber("h 20 22 64 6e 73 22 3a 20 7b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_method4 = true
    end
  end
  if hc_method4 then
    gg.searchNumber("h 7B 0A 09 09 09 09 09 09 09 09 09 09 09 09 22 61 64 64 72 65 73 73 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("address")
      hc_method5 = true
    end
  end
  if hc_method5 then
    gg.searchNumber("h 22 6c 6f 67 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("address")
      hc_method6 = true
    end
  end
  if hc_method6 then
    gg.searchNumber("h 22 6f 75 74 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("outbounds")
      hc_method7 = true
    end
  end
if hc_method7 then
    gg.searchNumber("h 22 6f 75 74 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_method8 = true
    end
  end  
  
  
  
  if hc_method8 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
    print("all metode failed\n")
    os.exit()
  end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()


function v2raySF()
function v2ray()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

   
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] ğ•ğŸğ‘ğšğ²"

    
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    v2rayx()
end

v2ray()
end

v2raySF()

local mode = {
"SSH â” Payload & V2ray",
"V2ray",
"SSH â” Payload",
"SSL â” SSH â” Direct",
"OpenVPN â” Payload",
"Payload â” OpenVPN",
"OpenVPN",
"V2ray â” Payload",
"SSH â” Direct",
"SSH â” Payload",
"Psiphon â” Payload",
"Payload",
}
local active_mode = ""
if pas and teste and proxy and testeddd then
active_mode = mode[1]
elseif testeddd then
active_mode = mode[2]
elseif host and teste then
active_mode = mode[3]
elseif sni and pas then
active_mode = mode[4]
elseif testedd then
active_mode = mode[5]
elseif teste and proxy and testedd then
active_mode = mode[6]
elseif testedd then
active_mode = mode[7]
elseif testeddd and teste then
active_mode = mode[8]
elseif pas then
active_mode = mode[9]
elseif SSH then
active_mode = mode[10]
elseif psiph and teste then
active_mode = mode[11]
elseif teste and proxy then
active_mode = mode[12]
else
active_mode = "";
end


local result = {
--    [1] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğ‡ğ¨ğ¬ğ­ : ",
--    ['DATA'] = host
--    },
--    [2] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğğ¨ğ«ğ­ : ",
--    ['DATA'] = port
--    },
--    [3] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğ”ğ¬ğğ« : ",
--    ['DATA'] = hostt
--    },
--    [4] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğğšğ¬ğ¬ : ",
--    ['DATA'] = pas
--    },
--     [1] = {
--     ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğğšğ²ğ¥ğ¨ğšğ : ",
--     ['DATA'] = teste
--    },
--    [6] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğğ«ğ¨ğ±ğ² : ",
--    ['DATA'] = proxy
--    },
--   	[7] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğğ©ğğ§ğ•ğğ : ",
--    ['DATA'] = testedd
--    },
--    [8] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğ’ğ’ğ‡ : ",
--    ['DATA'] = SSH
--    },
--    [9] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğ’ğ’ğ‹ : ",
--    ['DATA'] = sni
--    },
    [1] = {
    ['NAME'] = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ•2ğ«ğšğ² : ",
    ['DATA'] = testeddd
    },
--    [11] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğğ¬ğ¢ğ©ğ¡ğ¨ğ§ ğ€ğ®ğ­ğ¡ğ¨ğ«ğ¢ğ³ğšğ­ğ¢ğ¨ğ§",
--    ['DATA'] = psiph
--    },
--    [12] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğğ¬ğ¢ğ©ğ¡ğ¨ğ§ ğğ«ğ¨ğ­ğ¨ğœğ¨ğ¥",
--    ['DATA'] = psi
--    },
--    [13] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğ•ğğ«ğ¬ğ¢ğ¨ğ§ : ",
--    ['DATA'] = versi
--    },
--    [13] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğ“ğ¢ğ¦ğ : ",
--    ['DATA'] = xX
--    },
--    [15] = {
--    ['NAME'] = "â”£â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ”ƒ[âœµ] ğ“ğ®ğ§ğ§ğğ¥ ğ“ğ²ğ©ğ :",
--    ['DATA'] = active_mode
--    },
 
  }
  
local message = "```makefile\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚     [  ğ‘µğ‘·ğ‘½ğ‘» ğ‘»ğ‘¼ğ‘µğ‘µğ‘¬ğ‘³  ]\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ‚ğ¨ğğ ğğ²: ğ‘ºğ’‰ğ’‚ğ’‰ğ’“ğ’Šğ’‚ğ’“_ğ‘¿_ğ‘­ğ’‚ğ’‰ğ’Šğ’\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ†ğ«ğ¨ğ®ğ© : t.me/Decrypt_VPN_Files\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..""..names.."  ' "..value.." ' \n"
           end
            end
        
            message = message.."â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğƒğğœ ğğ² : @Shahriar_X_Fahim\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"
        local alert = gg.alert(message, "ğ‚ğğğ˜", "ğ„ğ—ğˆğ“")
        if alert == 1 then
        gg.copyText(message, false)

        elseif alert == 2 then
        end
      io.open('/sdcard/npvtV2RAYc.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  os.exit()
  end




  function NpvtV2RAY2()
limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
--ProgressBar = "éˆºæˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆº?";for x = 1,15,1 do gg.sleep(40) ---ProgressBar = ProgressBar:gsub("éˆ»?","éˆ»?",1);gg.toast(ProgressBar) end
    io.open(gg.EXT_STORAGE .. "/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP)
---gg.makeRequest("https://raw.githubusercontent.com/EstebanZxx/Forbidden/main/KEY-ACCESS") key= W4nn4P14yW1thKyy ğŸ¸ğŸ¸
gg.setVisible(false)
--gg.setVisible(false)
gg.searchNumber(":[lf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method2 = true
end

if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(":444@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method10 = true
end
end
if hc_method10 then
    gg.alert("No matching keywords!")
    os.exit()
end

local r = gg.getResults(100)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto invè°©lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invè°©lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "NèŒ«o foi possé“†vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invè°©lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "NèŒ«o foi possé“†vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "NèŒ«o foi possé“†vel ler o conteç…¤do do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt"

    -- Abre o arquivo no modo de escrita no diretè´¸rio do script
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        -- Construir a string com os valores a serem salvos
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saé“†da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depuraè½èŒ«o
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usuè°©rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saé“†da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt"
    local caminhoArquivoSaida = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    -- Criar ou abrir o arquivo de saé“†da
    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end

    -- Concatenar os resultados
local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
sshResults = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    -- Exibir e salvar os resultados
    exibirEInserir(arquivoSaida, " ", saida)
    
-- Fechar o arquivo de saé“†da
    arquivoSaida:close()
end    

processarSSHx()

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "***."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")

local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.")

function payloadx9()
function payload()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt
    local function payloadx()
        local arquivo = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
    ---        teste = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de saé“†da

    payloadx()
end

payload()
end

payloadx9()

function ovpnx9()
function ovpn()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt
    local function ovpnx()
        local arquivo = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end
             local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
---        testedd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de saé“†da

    ovpnx()
end

ovpn()
end

ovpnx9()

function v2rayx9()
function v2ray()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()
                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt
    local function v2rayx()
        local arquivo = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] é¥¾æ‚¤é¥¾ç…‡é¥¾æ‚œé¥¾æ‚®é¥¾æƒ’"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
 ---       testeddd= "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de saé“†da

    v2rayx()
end

v2ray()
end

v2rayx9()

function pythonx9()
function python()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedddd = (texto)
                local arquivoSaida = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt
    local function pythonx()
        local arquivo = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsPython = {'"ey', 'FRONTED-'}
    local labelPython = ""

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouPython = tentarEncontrarPalavrasChave(conteudo, keywordsPython, labelPython)

    if encontrouPython then
        print("")
    else
  --     testedddd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de saé“†da

    pythonx()
end

python()
end

pythonx9()

local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 

local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"

local sni = string.match(content, "[%w%.-]+:%d%d+[^é¦ƒæ§‡]-\0([%w%.-]-%.[%w.-]-)\0") 

local ns  = string.match(content, "false") or "false"

local pubkey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65][%w.-]+.") 

local psiphon = string.match(content, "[\x5b]\x22.*]") or false

local versi = string.match(content, "645") or "645"

local xX = os.date("%d/%m/%Y %I:%M:%S")

--local xX = os.date("%I:%M %p")

function keyx9()
function key()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                pub = (texto) 
                local arquivoSaida = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt
    local function keyx()
        local arquivo = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"b22", "bc2c"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
     ---       pub = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de saé“†da

    keyx()
end

key()
end

keyx9()

function slowdnsx9()
function slowdns()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                name = (texto)
                local arquivoSaida = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt
    local function slowdnsx()
        local arquivo = io.open("/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsSlowdns = {"ns", "n%s-"}
        local labelSlowdns = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouSlowdns = tentarEncontrarPalavrasChave(conteudo, keywordsSlowdns, labelSlowdns)

        if encontrouSlowdns then
            print("")
        else
        --    name = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt" -- caminho do arquivo de saé“†da

    slowdnsx()
end

slowdns()
end

slowdnsx9()

local SlowDnsServer = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local PubKey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65]+")
local SSLSNI = string.match(content, "[%w]-%.[%w]-%.[%w]-")

local result = {
--    [1] = {
--    ['NAME'] = "\nâ”‚[ãƒ ] ğğšğ²ğ¥ğ¨ğšğ : ",
--    ['DATA'] = teste
--    },
--	[2] = {
--    ['NAME'] = "\nâ”‚[ãƒ ] ğğ«ğ¨ğ±ğ² : ",
--    ['DATA'] = proxy
--    },
--    [3] = {
--    ['NAME'] = "\nâ”‚[ãƒ ] ğ’ğ’ğ‡ : ",
--    ['DATA'] = sshResults
--    },
--    [4] = {
 --   ['NAME'] = "\nâ”‚[ãƒ ] ğ’ğ’ğ‹ : ",
--    ['DATA'] = SSLSNI
--    },
    [1] = {
    ['NAME'] = "\nâ”‚[âœ¿] ğ•2ğ‘ğ€ğ˜ : ",
    ['DATA'] = testeddd    },
--    [6] = {
--    ['NAME'] = "\nâ”‚[ãƒ ] ğğ’ğˆğğ‡ğğ : ",
--    ['DATA'] = testedddd
--    },
--    [7] = {
--    ['NAME'] = "\nâ”‚[ãƒ ] ğğ•ğğ : ",
    ['DATA'] = testedd
--    },

  }
  
  local message = "```json\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ¿] ğ‚ğ¨ğğ ğğ² : @Shahriar_X_Fahim\nâ”‚[âœ¿] ğ†ğ«ğ¨ğ®ğ© : t.me/Decrypt_VPN_Files"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message.."\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"..names.." ' "..value.." ' "
           end
            end
         
            message = message.."\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ¿] ğƒğğœğ«ğ²ğ©ğ­ ğğ² : @Shahriar_X_Fahim\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"
        local alert = gg.alert(message, "ğ’ğ€ğ•ğ„", "ğ‚ğ€ğğ‚ğ„ğ‹")
        if alert == 1 then
        gg.copyText(message, false)
        gg.toast("Copied To Clipboard")
        elseif alert == 2 then
        end
      io.open('/sdcard/#ğ‡ğ‚-ğğğ•ğ“_ğŸ‡§ğŸ‡©.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  end











function DarkTunnel()
  function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, endereÃ§o fornecido Ã© nulo.")
  
  _rw = {}

  if type(SizeOrBuffer) == "number" then
    _ = ""
    for SRD1_5_ = 1, SizeOrBuffer do
      _rw[SRD1_5_] = {
        address = Address - 1 + SRD1_5_,
        flags = gg.TYPE_BYTE
      }
    end

    for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
      if SRD1_6_.value == 0 and limit == true then
        return _
      end
      _ = _ .. string.format("%02X", SRD1_6_.value & 255)
    end

    return _
  end

  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end)

  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("NÃ£o foi possÃ­vel transmitir '" .. tostring(number) .. "' enumerar.'"))
end

function save(data)
  io.open("/sdcard/decrypt.txt", "w"):write(data)
end

limit = true
gg.clearResults()
gg.setVisible(false)
gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_C_DATA)
gg.setSpeed(20.0)

local function searchAndSave(searchText)
  gg.searchNumber(searchText, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local result = gg.getResults(1)

  if #result > 0 then
    if limit == false then
      result[1].address = result[1].address - 8192
    end
    readedMem = rwmem(result[1].address, 10000)
    save(hexdecode(readedMem))
    return true
  end

  return false
end

  local tests = {
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22 2C',
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22 2C',
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22',
    'h 3a 56 65 72 73 69 6f 6e 43 6f 64 65',
  }

local addressFound = false

for i, searchText in ipairs(tests) do
  if searchAndSave(searchText) then
    addressFound = true
    break
  end
end

if not addressFound then
  gg.alert("Decryption failed. Re-import the file and run the script.")
  
  
  os.exit()
end

local f = io.open("/sdcard/decrypt.txt", "r")
local dark = f:read("*all")
f:close()

dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')
dark = string.gsub(dark, 'text', 'value')

dark = string.gsub(dark, "^%s*(.-)%s*$", "%1")

local f = io.open("/sdcard/decrypt.txt", "w")
f:write(dark)
f:close()

targetInfo = gg.getTargetInfo()
app = targetInfo.packageName
local label = gg.getTargetInfo().label or "N/A"

local currentDate = os.date("*t")
local data = os.date("%d/%m/%Y")

local message = "```makefile\nâ”Œâ”€[' @Shahriar_X_Fahim '] \nâ”Š'â§¼ ğ’®ğ’½ğ’¶ğ’½ğ“‡ğ’¾ğ“‡_ğ’³_â„±ğ’¶ğ’½ğ’¾ğ“‚ â§½'\nâ”‚'â§¼ DARK TUNNEL â§½'\nâ”œâ”€â”€â”€â•¼[' t.me/Decrypt_VPN_Files ']\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ—©2ğ—¥ğ—”ğ—¬ :  ' " .. dark .. " ' \nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â–] ğ——ğ—²ğ—°ğ—¿ğ˜†ğ—½ğ˜ ğ—•ğ˜† :' @Shahriar_X_Fahim'\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"

gg.alert(message, 'Copy and exit')
gg.copyText(message, false)

local f = io.open("/sdcard/decrypt.txt", "w")
f:write(message)
f:close()
gg.setVisible(false)
end

function HTTPCUSTOM3()
limit = false
 -- gg.setVisible(true)
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for _FORV_5_ = 1, SizeOrBuffer do
            _rw[_FORV_5_] = {
              address = Address - 1 + _FORV_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for _FORV_5_, _FORV_6_ in ipairs(gg.getValues(_rw)) do
            if _FORV_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", _FORV_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
  end
  
  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end
  
  function hexencode(str)
    return (str:gsub(".", function(char)
      return string.format("%2x", char:byte())
    end
    ))
  end
  
  function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
  end
  
    function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
  end
  
  function save(data)
    local function hexencode_spasi(str)
      return (str:gsub(".", function(char)
          return string.format("%02x ", char:byte())
      end))
    end

    local function checkMatch(key, str)
      result = nil
      
      for index, value in ipairs(key) do
          result = str:match(value)
          if result then 
              break 
          end
      end
      
      return result
    end

    local function strip(s)
      return (s:gsub("^%s*(.-)%s*$", "%1"))
    end

    local function prosesData(data)

      local function findExpDate(tbl)
          local key = {
              "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d",
              "lifeTime"
          } 
          local result = nil
          
          for index_tbl, value_tbl in ipairs(tbl) do
  
              for index_key, value_key in ipairs(key) do
                  
                  if value_tbl:match(value_key) then
                      result = index_tbl
                  end
  
              end
          end
          return result
      end
  
      local function splitString(str, separator)
          local match_1, match_2 = str:match("(.-)"..separator.."(.*)")
          local tbl = {}
  
          no = 1
          while (match_2:match("(.-)"..separator.."(.*)") and no < 100) do
      
              match_1, match_2 = match_2:match("(.-)"..separator.."(.*)")
      
              if hexdecode(match_1):match("[^\x20]+") then
                  table.insert(tbl, strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
              else 
                  table.insert(tbl,'')
              end
              
              no = no + 1
          end
  
          return tbl
      end
  
      local function fixedConfig(index, tbl)
          local result_fixedConfig = {}
          local beginIndex = index - 4
          local lastIndex = beginIndex + 31
  
          for i = beginIndex, lastIndex do
              table.insert(result_fixedConfig, tbl[i])
          end
  
          return result_fixedConfig
      end
      data = hexencode_spasi(data)
      data = data:gsub("00", "20")
      data = data:gsub("20", "z")
      data = data:gsub("66 61 6c 73 65", "F A L S E")
      data = data:gsub("\x20", "")
      data = data:gsub("\n", "")
      local separator = data:match("FALSE[\x7a]+(.-)[\x7a]+")
      data = data:gsub(separator, "0a56616c647947616e74656e67")
      separator = "0a56616c647947616e74656e67"
      data = data:gsub("z", "20")
      data = data:gsub("FALSE", "66616c7365")

      local result = splitString(data, separator)
      local assemblyPointIndex = findExpDate(result)
      local getConfig = fixedConfig(assemblyPointIndex, result)
  
      return getConfig
    end

    local function getOutput(tbl)
      local cfgRegex = {
        [1] = {
            ["name"] = "Payload",
            ["regex"] = "(.*)"  
     --   }, 
    --    [1] = {
        --    ["name"] = "Payload",
        --    ["regex"] = "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d]+"     
        },
        [2] = {
            ["name"] = "Proxy",
            ["regex"] = "(.*)"      
    --       ["regex"] = "[%w\x2e]+[\x3a][%d]+"
        },
        [3] = {
            ["name"] = "BlockRoot",
            ["regex"] = "(.*)"
        },
        [4] = {
            ["name"] = "ExtraSniffer",
            ["regex"] = "(.*)"
        },
        [5] = {
            ["name"] = "Expired",
            ["regex"] = "(.*)"
            
            
 --      },
  --     [6] = {
     --      ["name"] = "ExtraNotes",
    --      ["regex"] = "(.*)"
--       },
  --      [7] = {
   --      ["name"] = "Notes",
          -- ["regex"] = "(.*)"
         
        },
        [8] = {
            ["name"] = "Ssh", 
      --   ["regex"] = "(.*)"
         ["regex"] = "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+"
        },
        [9] = {
            ["name"] = "LockProvider",
            ["regex"] = "(.*)"
        },
        [10] = {
            ["name"] = "ProviderID", 
            ["regex"] = "[0-9]"
        },
        [11] = {
            ["name"] = "OpenVPN-Cerf",
            ["regex"] = "(.*)"
        },
        [12] = {
            ["name"] = "OpenVPN-User:Pass",
            ["regex"] = "(.*)"
        },
        [13] = {
            ["name"] = "SNI",
         ["regex"] = "(.*)"
          
        -- ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"

       },
        [15] = {
            ["name"] = "PortUDPGW",
            ["regex"] = "(.*)"
            
        },
        [17] = {
            ["name"] = "LockHWID",
            ["regex"] = "(.*)"
        },
        [18] = {
            ["name"] = "ValueHWID",
            ["regex"] = "(.*)"
            
        },
        [19] = {
            ["name"] = "NickPowerd",
            ["regex"] = "(.*)"
            
--        [20] = {
--            ["name"] = "@Shahriar_X_Fahim",
--            ["regex"] = "(.*)"
--        },
--        [21] = {
--            ["name"] = "URL",
--            ["regex"] = "(.*)"
        },
        [22] = {
            ["name"] = "BypassPassword",
            ["regex"] = "(.*)"
        },
        [23] = {
            ["name"] = "Password",
            ["regex"] = "[a-zA-Z0-9]"
        }, 
        [24] = {
            ["name"] = "PsihonMode",
            ["regex"] = "(.*)"            
        }, 
        [25] = {
            ["name"] = "PsiphonAuthorizon",
            --["regex"] = "(.*)"      
           ["regex"] = "[\x5b]\x22.*]"
            
        },   
        [26] = {
            ["name"] = "V2RayMode",
            ["regex"] = "(.*)"
        },
        [27] = {
            ["name"] = "V2Ray",
            ["regex"] = "(.*)"
        },
        [29] = {
         ["name"] = "SlowDNSMode", 
         ["regex"] = "(.*)" 
                    
       }, 
        [28] = {
            ["name"] = "VerApp",
            ["regex"] = "(.*)"
       },
        [30] = {
            ["name"] = "NameServer",
       --     ["regex"] = "(.*)"
      ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"
        },
        [31] = {
            ["name"] = "Public Key", 
         --   ["regex"] = "(.*)"
           ["regex"] = "[a-f0-9]+[32,64,50,66,61,6c,73,65]+"
        },
        [32] = {
            ["name"] = "DNS Host",
         --   ["regex"] = "(.*)"
            ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"
        }
    }
       
      
      local message = "```java\n'â§¼ Shahriar_X_Fahim â§½ '\n' t.me/Decrypt_VPN_Files '\n\n{ \n\n     ''HttpCustom Decrypt'': \n"
      
      for index, value in ipairs(tbl) do
          
          if cfgRegex[index] and value:match(cfgRegex[index]["regex"]) then
              local namaKonten = cfgRegex[index]["name"]
              local valueRegexKonten = value:match(cfgRegex[index]["regex"])
  
              message = message.."     ''"
              message = message..namaKonten.."'': ''"..valueRegexKonten.."'',\n"
          end
          
      end
  
      message = message.."\n}\n```"
      return message
    end


    local contentToDecrypt = hexdecode(data)
    contentToDecrypt = prosesData(hexdecode(data))
    local hasil = getOutput(contentToDecrypt)
    io.open(gg.EXT_STORAGE .. "/#HC_JAVAğŸ‡§ğŸ‡©.txt", "w"):write(hexdecode(data))
     
    gg.copyText(hasil, false)
    gg.toast(hasil)
    print(hasil)
 end

 gg.setVisible(false)
-- gg.processPause()
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setSpeed(20.0)
  gg.searchNumber(":GET / HTTP", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("KEY 1")
    hc_method2 = true
  end
  if hc_method2 then
    gg.searchNumber("Host: ", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 2")
      hc_method3 = true
    end
  end
  if hc_method3 then
    gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 3")
      hc_method4 = true
    end
  end
  if hc_method4 then
    gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 4")
      hc_method5 = true
    end
  end
  if hc_method5 then
    gg.searchNumber("Upgrade: websocket", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 5")
      hc_method6 = true
    end
  end
  if hc_method6 then
    gg.searchNumber(":GET wss:", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 6")
      hc_method7 = true
    end
  end
  if hc_method7 then
    gg.searchNumber(":[splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 7")
      hc_method8 = true
    end
  end
  if hc_method8 then
    print("All methods failed")
    os.exit()
  end

    local r = gg.getResults(1)
  if limit == false then
    r[1].address = r[1].address - 0x2000
  end 
  readedMem = rwmem(r[1].address, 15000)
  save(readedMem)
  gg.clearResults()
end







function HTTPCUSTOM2()
limit = false
 -- gg.setVisible(true)
  function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
      _ = ""
      do
        do
          for _FORV_5_ = 1, SizeOrBuffer do
            _rw[_FORV_5_] = {
              address = Address - 1 + _FORV_5_,
              flags = gg.TYPE_BYTE
            }
          end
        end
      end
      do
        do
          for _FORV_5_, _FORV_6_ in ipairs(gg.getValues(_rw)) do
            if _FORV_6_.value == 0 and limit == true then
              return _
            end
            _ = _ .. string.format("%02X", _FORV_6_.value & 255)
          end
        end
      end
      return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
      Byte[#Byte + 1] = x
      _rw[#Byte] = {
        address = Address - 1 + #Byte,
        flags = gg.TYPE_BYTE,
        value = x .. "h"
      }
    end
    )
    gg.setValues(_rw)
  end
  
  function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits)
      return string.char(tonumber(digits, 16))
    end
    ))
  end
  
  function hexencode(str)
    return (str:gsub(".", function(char)
      return string.format("%2x", char:byte())
    end
    ))
  end
  
  function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
  end
  
    function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
  end
  
  function save(data)
    local function hexencode_spasi(str)
      return (str:gsub(".", function(char)
          return string.format("%02x ", char:byte())
      end))
    end

    local function checkMatch(key, str)
      result = nil
      
      for index, value in ipairs(key) do
          result = str:match(value)
          if result then 
              break 
          end
      end
      
      return result
    end

    local function strip(s)
      return (s:gsub("^%s*(.-)%s*$", "%1"))
    end

    local function prosesData(data)

      local function findExpDate(tbl)
          local key = {
              "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d",
              "lifeTime"
          } 
          local result = nil
          
          for index_tbl, value_tbl in ipairs(tbl) do
  
              for index_key, value_key in ipairs(key) do
                  
                  if value_tbl:match(value_key) then
                      result = index_tbl
                  end
  
              end
          end
          return result
      end
  
      local function splitString(str, separator)
          local match_1, match_2 = str:match("(.-)"..separator.."(.*)")
          local tbl = {}
  
          no = 1
          while (match_2:match("(.-)"..separator.."(.*)") and no < 100) do
      
              match_1, match_2 = match_2:match("(.-)"..separator.."(.*)")
      
              if hexdecode(match_1):match("[^\x20]+") then
                  table.insert(tbl, strip(hexdecode(match_1):gsub("[^\x20-\x7e]+","")))
              else 
                  table.insert(tbl,'')
              end
              
              no = no + 1
          end
  
          return tbl
      end
  
      local function fixedConfig(index, tbl)
          local result_fixedConfig = {}
          local beginIndex = index - 4
          local lastIndex = beginIndex + 31
  
          for i = beginIndex, lastIndex do
              table.insert(result_fixedConfig, tbl[i])
          end
  
          return result_fixedConfig
      end
      data = hexencode_spasi(data)
      data = data:gsub("00", "20")
      data = data:gsub("20", "z")
      data = data:gsub("66 61 6c 73 65", "F A L S E")
      data = data:gsub("\x20", "")
      data = data:gsub("\n", "")
      local separator = data:match("FALSE[\x7a]+(.-)[\x7a]+")
      data = data:gsub(separator, "0a56616c647947616e74656e67")
      separator = "0a56616c647947616e74656e67"
      data = data:gsub("z", "20")
      data = data:gsub("FALSE", "66616c7365")

      local result = splitString(data, separator)
      local assemblyPointIndex = findExpDate(result)
      local getConfig = fixedConfig(assemblyPointIndex, result)
  
      return getConfig
    end

    local function getOutput(tbl)
      local cfgRegex = {
        [1] = {
            ["name"] = "Payload",
            ["regex"] = "(.*)"  
     --   }, 
    --    [1] = {
        --    ["name"] = "Payload",
        --    ["regex"] = "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d]+"     
        },
        [2] = {
            ["name"] = "Proxy",
            ["regex"] = "(.*)"      
    --       ["regex"] = "[%w\x2e]+[\x3a][%d]+"
        },
        [3] = {
            ["name"] = "BlockRoot",
            ["regex"] = "(.*)"
        },
        [4] = {
            ["name"] = "ExtraSniffer",
            ["regex"] = "(.*)"
        },
        [5] = {
            ["name"] = "Expired",
            ["regex"] = "(.*)"
            
            
 --      },
  --     [6] = {
     --      ["name"] = "ExtraNotes",
    --      ["regex"] = "(.*)"
--       },
  --      [7] = {
   --      ["name"] = "Notes",
          -- ["regex"] = "(.*)"
         
        },
        [8] = {
            ["name"] = "Ssh", 
      --   ["regex"] = "(.*)"
         ["regex"] = "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+"
        },
        [9] = {
            ["name"] = "LockProvider",
            ["regex"] = "(.*)"
        },
        [10] = {
            ["name"] = "ProviderID", 
            ["regex"] = "[0-9]"
        },
        [11] = {
            ["name"] = "OpenVPN-Cerf",
            ["regex"] = "(.*)"
        },
        [12] = {
            ["name"] = "OpenVPN-User:Pass",
            ["regex"] = "(.*)"
        },
        [13] = {
            ["name"] = "SNI",
         ["regex"] = "(.*)"
          
        -- ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"

       },
        [15] = {
            ["name"] = "PortUDPGW",
            ["regex"] = "(.*)"
            
        },
        [17] = {
            ["name"] = "LockHWID",
            ["regex"] = "(.*)"
        },
        [18] = {
            ["name"] = "ValueHWID",
            ["regex"] = "(.*)"
            
        },
        [19] = {
            ["name"] = "NickPowerd",
            ["regex"] = "(.*)"
            
--        [20] = {
--            ["name"] = "@Shahriar_X_Fahim",
--            ["regex"] = "(.*)"
--        },
--        [21] = {
--            ["name"] = "URL",
--            ["regex"] = "(.*)"
        },
        [22] = {
            ["name"] = "BypassPassword",
            ["regex"] = "(.*)"
        },
        [23] = {
            ["name"] = "Password",
            ["regex"] = "[a-zA-Z0-9]"
        }, 
        [24] = {
            ["name"] = "PsihonMode",
            ["regex"] = "(.*)"            
        }, 
        [25] = {
            ["name"] = "PsiphonAuthorizon",
            --["regex"] = "(.*)"      
           ["regex"] = "[\x5b]\x22.*]"
            
        },   
        [26] = {
            ["name"] = "V2RayMode",
            ["regex"] = "(.*)"
        },
        [27] = {
            ["name"] = "V2Ray",
            ["regex"] = "(.*)"
        },
        [29] = {
         ["name"] = "SlowDNSMode", 
         ["regex"] = "(.*)" 
                    
       }, 
        [28] = {
            ["name"] = "VerApp",
            ["regex"] = "(.*)"
       },
        [30] = {
            ["name"] = "NameServer",
       --     ["regex"] = "(.*)"
      ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"
        },
        [31] = {
            ["name"] = "Public Key", 
         --   ["regex"] = "(.*)"
           ["regex"] = "[a-f0-9]+[32,64,50,66,61,6c,73,65]+"
        },
        [32] = {
            ["name"] = "DNS Host",
         --   ["regex"] = "(.*)"
            ["regex"] = "[%w\x2e\x2d]+[\x2e]+[%w]+"
        }
    }
       
      
      local message = "```java\nâ§¼ Shahriar_X_Fahim â§½ \nt.me/Decrypt_VPN_Files \n\n{ \n\n     ''HttpCustom Decrypt'': \n"
      
      for index, value in ipairs(tbl) do
          
          if cfgRegex[index] and value:match(cfgRegex[index]["regex"]) then
              local namaKonten = cfgRegex[index]["name"]
              local valueRegexKonten = value:match(cfgRegex[index]["regex"])
  
              message = message.."     ''"
              message = message..namaKonten.."'': ''"..valueRegexKonten.."'',\n"
          end
          
      end
  
      message = message.."\n}\n```"
      return message
    end


    local contentToDecrypt = hexdecode(data)
    contentToDecrypt = prosesData(hexdecode(data))
    local hasil = getOutput(contentToDecrypt)
    io.open(gg.EXT_STORAGE .. "/#HC_JAVAğŸ‡§ğŸ‡©.txt", "w"):write(hexdecode(data))
     
    gg.copyText(hasil, false)
    gg.toast(hasil)
    print(hasil)
 end

 gg.setVisible(false)
-- gg.processPause()
  gg.setRanges(gg.REGION_JAVA_HEAP)
  gg.setSpeed(20.0)
  gg.searchNumber(":GET / HTTP", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("KEY 1")
    hc_method2 = true
  end
  if hc_method2 then
    gg.searchNumber("Host: ", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 2")
      hc_method3 = true
    end
  end
  if hc_method3 then
    gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 3")
      hc_method4 = true
    end
  end
  if hc_method4 then
    gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 4")
      hc_method5 = true
    end
  end
  if hc_method5 then
    gg.searchNumber("Upgrade: websocket", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 5")
      hc_method6 = true
    end
  end
  if hc_method6 then
    gg.searchNumber(":GET wss:", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 6")
      hc_method7 = true
    end
  end
  if hc_method7 then
    gg.searchNumber(":[splitPsiphon]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("KEY 7")
      hc_method8 = true
    end
  end
  if hc_method8 then
    print("All methods failed")
    os.exit()
  end

    local r = gg.getResults(1)
  if limit == false then
    r[1].address = r[1].address - 0x2000
  end 
  readedMem = rwmem(r[1].address, 15000)
  save(readedMem)
  gg.clearResults()
end












function HC()
limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
--ProgressBar = "éˆºæˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆ»æˆ”æ’éˆº?";for x = 1,15,1 do gg.sleep(40) ---ProgressBar = ProgressBar:gsub("éˆ»?","éˆ»?",1);gg.toast(ProgressBar) end
    io.open(gg.EXT_STORAGE .. "/HTTP_CUSTOM.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP)
---gg.makeRequest("https://raw.githubusercontent.com/EstebanZxx/Forbidden/main/KEY-ACCESS") key= W4nn4P14yW1thKyy ğŸ¸ğŸ¸
gg.setVisible(false)
--gg.setVisible(false)
gg.searchNumber(":[lf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method2 = true
end

if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(":444@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then
    
    hc_method10 = true
end
end
if hc_method10 then
    gg.alert("No matching keywords!")
    os.exit()
end

local r = gg.getResults(100)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/HTTP_CUSTOM.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/HTTP_CUSTOM.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto invè°©lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invè°©lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "NèŒ«o foi possé“†vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invè°©lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "NèŒ«o foi possé“†vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "NèŒ«o foi possé“†vel ler o conteç…¤do do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/HTTP_CUSTOM.txt"

    -- Abre o arquivo no modo de escrita no diretè´¸rio do script
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        -- Construir a string com os valores a serem salvos
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saé“†da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depuraè½èŒ«o
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "Usuè°©rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saé“†da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt"
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    -- Criar ou abrir o arquivo de saé“†da
    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end

    -- Concatenar os resultados
local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
sshResults = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    -- Exibir e salvar os resultados
    exibirEInserir(arquivoSaida, " ", saida)
    
-- Fechar o arquivo de saé“†da
    arquivoSaida:close()
end    

processarSSHx()

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "***."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")

local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.")

function payloadx9()
function payload()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function payloadx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
    ---        teste = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    payloadx()
end

payload()
end

payloadx9()

function ovpnx9()
function ovpn()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function ovpnx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
---        testedd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    ovpnx()
end

ovpn()
end

ovpnx9()

function v2rayx9()
function v2ray()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function v2rayx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] é¥¾æ‚¤é¥¾ç…‡é¥¾æ‚œé¥¾æ‚®é¥¾æƒ’"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
 ---       testeddd= "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    v2rayx()
end

v2ray()
end

v2rayx9()

function pythonx9()
function python()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedddd = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function pythonx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsPython = {'"ey', 'FRONTED-'}
    local labelPython = ""

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouPython = tentarEncontrarPalavrasChave(conteudo, keywordsPython, labelPython)

    if encontrouPython then
        print("")
    else
  --     testedddd = "false"
    end
end


    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    pythonx()
end

python()
end

pythonx9()

local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 

local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"

local sni = string.match(content, "[%w%.-]+:%d%d+[^é¦ƒæ§‡]-\0([%w%.-]-%.[%w.-]-)\0") 

local ns  = string.match(content, "false") or "false"

local pubkey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65][%w.-]+.") 

local psiphon = string.match(content, "[\x5b]\x22.*]") or false

local versi = string.match(content, "645") or "645"

local xX = os.date("%d/%m/%Y %I:%M:%S")

--local xX = os.date("%I:%M %p")

function keyx9()
function key()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                pub = (texto) 
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function keyx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"b22", "bc2c"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
     ---       pub = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    keyx()
end

key()
end

keyx9()

function slowdnsx9()
function slowdns()
    -- Funè½èŒ«o para remover bytes nulos do iné“†cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- Funè½èŒ«o para tentar encontrar palavras-chave e salvar informaè½ç«es
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trè°©s atèŒ… encontrar o iné“†cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atèŒ… encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                name = (texto)
                local arquivoSaida = io.open("/sdcard/HTTP_CUSTOM.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saé“†da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- Funè½èŒ«o para decodificar a payload e salvar no arquivo /sdcard/HTTP_CUSTOM.txt
    local function slowdnsx()
        local arquivo = io.open("/sdcard/HTTP_CUSTOM.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsSlowdns = {"ns", "n%s-"}
        local labelSlowdns = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouSlowdns = tentarEncontrarPalavrasChave(conteudo, keywordsSlowdns, labelSlowdns)

        if encontrouSlowdns then
            print("")
        else
        --    name = "false"
        end
    end

    local caminhoArquivoEntrada = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/HTTP_CUSTOM.txt" -- caminho do arquivo de saé“†da

    slowdnsx()
end

slowdns()
end

slowdnsx9()

local SlowDnsServer = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local PubKey = string.match(content, "[a-f0-9]+[32,64,50,66,61,6c,73,65]+")
local SSLSNI = string.match(content, "[%w]-%.[%w]-%.[%w]-")

local result = {
    [1] = {
    ['NAME'] = "\nâ”‚[âœ©] ğ’ğ’ğ‡ : ",
    ['DATA'] = teste
    },
	[2] = {
    ['NAME'] = "\nâ”‚[âœ©] ğğ‘ğğ—ğ˜ : ",
    ['DATA'] = proxy
    },
    [3] = {
    ['NAME'] = "\nâ”‚[âœ©] ğ’ğ’ğ‡ : ",
    ['DATA'] = sshResults
    },
    [4] = {
    ['NAME'] = "\nâ”‚[âœ©] ğ’ğ’ğ‹ : ",
    ['DATA'] = SSLSNI
    },
    [5] = {
    ['NAME'] = "\nâ”‚[âœ©] ğ•2ğ‘ğ€ğ˜ : ",
    ['DATA'] = testeddd
    },
    [6] = {
    ['NAME'] = "\nâ”‚[âœ©] ğğ’ğˆğğ‡ğğ : ",
    ['DATA'] = testedddd
    },
    [7] = {
    ['NAME'] = "\nâ”‚[âœ©] ğğ•ğğ : ",
    ['DATA'] = testedd
    },

  }
  
      local message = "```makefile\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ©] ğ‚ğğƒğ„ ğğ˜ : @Shahriar_X_Fahim\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ©] ğ†ğ‘ğğ”ğ : t.me/Decrypt_VPN_Files"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message.."\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"..names.." ' "..value.." ' "
           end
            end
         
            message = message.."\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ©] ğƒğ„ğ‚ ğğ˜ : @Shahriar_X_Fahim\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"
        local alert = gg.alert(message, "ğ’ğ€ğ•ğ„", "ğ„ğ—ğˆğ“")
        if alert == 1 then
        gg.copyText(message, false)
        gg.toast("Copied To Clipboard")
        elseif alert == 2 then
        end
      io.open('/sdcard/HTTP_CUSTOM.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  end


function HcDNS()

limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
gg.toast("Decrypt Successful")
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_ANONYMOUS)
gg.setSpeed(20.0)
gg.setVisible(false)

gg.searchNumber(":lf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then   
    hc_method2 = true
end
if hc_method2 then 
gg.searchNumber(":80@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(':22@', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":143@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':dns.', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method9 = true
    
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method10 = true
end
end

if hc_method10 then 
gg.searchNumber("h 5D 48 6F 73 74", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method11 = true
end
end


if hc_method11 then 
gg.searchNumber("h 5D 00 48 00 6F 00 73 00 74 00", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method12 = true
end
end

if hc_method12 then 
gg.searchNumber(":]User", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method13 = true
end
end

if hc_method13 then 
gg.searchNumber(":]Upgrade", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method14 = true
end
end

if hc_method14 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method15 = true
end
end


if hc_method15 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method16 = true
end
end


if hc_method16 then 
gg.searchNumber(":edfe9c3", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method17 = true
end
end





if hc_method17 then
gg.alert("Failed All Key ")
os.exit()
end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto invÃ¡lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "NÃ£o foi possÃ­vel ler o conteÃºdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/decrypt.txt"

    -- Abre o arquivo no modo de escrita no diretÃ³rio do script
    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        -- Construir a string com os valores a serem salvos
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saÃ­da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)
    -- Linhas de depuraÃ§Ã£o
     --print(val1, val2, val11, 2 ^ val22, val3, car)
     --save(val1, val2, val11, val22, val3, car)
     --save(val1, val2, val1, val2, val3, car)
    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "UsuÃ¡rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saÃ­da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end


local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    exibirEInserir(arquivoSaida, " ", saida)
    
    arquivoSaida:close()
end    

processarSSHx()

function payloadx9()
function payload()
    -- FunÃ§Ã£o para remover bytes nulos do inÃ­cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- FunÃ§Ã£o para tentar encontrar palavras-chave e salvar informaÃ§Ãµes
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trÃ¡s atÃ© encontrar o inÃ­cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atÃ© encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end
        local function payloadx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        -- Testa todas as palavras-chave para o Payload
        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
            teste = " "
        end
    end

    local caminhoArquivoEntrada = "/sdcard/decrypt.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/hc.txt" -- caminho do arquivo de saÃ­da

    payloadx()
end

payload()
end

payloadx9()

function ovpnx9()
function ovpn()
    -- FunÃ§Ã£o para remover bytes nulos do inÃ­cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- FunÃ§Ã£o para tentar encontrar palavras-chave e salvar informaÃ§Ãµes
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trÃ¡s atÃ© encontrar o inÃ­cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atÃ© encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- FunÃ§Ã£o para decodificar a payload e salvar no arquivo /sdcard/decrypt.txt
    local function ovpnx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
        testedd = " "
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/hc.txt" -- caminho do arquivo de saÃ­da

    ovpnx()
end

ovpn()
end

ovpnx9()

function v2rayx9()
function v2ray()
    -- FunÃ§Ã£o para remover bytes nulos do inÃ­cio e do final do texto
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    -- FunÃ§Ã£o para tentar encontrar palavras-chave e salvar informaÃ§Ãµes
    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                -- Percorre para trÃ¡s atÃ© encontrar o inÃ­cio real do JSON
                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                -- Percorre para frente atÃ© encontrar o final real do JSON
                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

                -- Exibe e salva no arquivo
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    -- FunÃ§Ã£o para decodificar a payload e salvar no arquivo /sdcard/decrypt.txt
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = ""

    -- Testa todas as palavras-chave para o OpenVPN
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
        testeddd= " "
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt" -- caminho do arquivo de entrada
    local caminhoArquivoSaida = "/sdcard/hc.txt" -- caminho do arquivo de saÃ­da

    v2rayx()
end

v2ray()
end

v2rayx9()

-- Don't move this string
local start = "```makefile\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ©] ğ†ğ«ğ¨ğ®ğ© :' t.me/Decrypt_VPN_Files '\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ©] ğ‚ğ¨ğğ ğğ² : '@Shahriar_X_Fahim '\n"
local final = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ©] ğƒğğœ ğğ² :' @Shahriar_X_Fahim '\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"

-- Payload filter string and ssh no encrypt
local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5blf\x5d+]+") or " "
local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.")

-- Psiphon filter string
local psiph = string.match(content, '[%S]+FRONTED') or " "
local psi = string.match(content, '%FRONTED.-[%w]+[%S][%w]+') or " "

-- Proxy filter string & SNI
local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+\0") or " "
local sni = string.match(content, "[%w%.-]+:%d%d+[^ğŸ˜ˆ]-\0([%w%.-]-%.[%w.-]-)\0") or " "

-- slowdns filter string
local pubkey = string.match(content, "[a-zA-Z0-9-]+[a-zA-Z]+[a-zA-Z]+[1,63]+%d%w+") or " "
local dns = string.match(content, "%d%d+[^ğŸ˜ˆ]-\0([%d%.-]-%.[%d.-]-)\0") or " "
local server = string.match(content, "%w%w+[^ğŸ˜ˆ]-\0([%w%.-]-%.[%w.-]-)\0\0") or " "

-- More filter string
local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"
local versi = string.match(content, "645") or "645"
local xX = os.date("%d/%m/%Y %I:%M:%S") or " "
local hwid = string.match(content, "false") or "false"
local udpw = string.match(content, "7300") or "7300"

-- do not edit this string
local message = start

local function Shahriar_X_Fahim(label, value)
  if value and value ~= "" then
    message = message .. "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â˜¼] [" .. label .. "] :  ' " .. value .. " ' \n"
  end
end

Shahriar_X_Fahim("ğ’ğ’ğ‡ ğ€ğğğ«ğğ¬ğ¬", result)
--Shahriar_X_Fahim("ğ’ğ’ğ‡", SSH)
Shahriar_X_Fahim("ğğšğ²ğ¥ğ¨ğšğ", PAYLOADD)
Shahriar_X_Fahim("ğğ«ğ¨ğ±ğ²", proxy)
Shahriar_X_Fahim("ğ’ğğˆ", sni)
Shahriar_X_Fahim("ğ•ğŸğ«ğšğ²", testeddd)
Shahriar_X_Fahim("ğğšğ¦ğğ’ğğ«ğ¯ğğ«", server)
Shahriar_X_Fahim("ğƒğ¨ğ¦ğšğ¢ğ§ğƒğğ’", dns)
Shahriar_X_Fahim("ğğ®ğ›ğ¥ğ¢ğœ ğŠğğ²", pubkey)
Shahriar_X_Fahim("ğğ¯ğ©ğ§ğ‚ğğ«ğ­", testedd)
Shahriar_X_Fahim("ğ”ğƒğ ğ€ğğğ«ğğ¬ğ¬", udpgw)
Shahriar_X_Fahim("ğğ¬ğ¢ğ©ğ¡ğ¨ğ§ğ€ğ®ğ­ğ¡ğ¨ğ«ğ¢ğ³ğšğ­ğ¢ğ¨ğ§", psiph)
Shahriar_X_Fahim("ğğ¬ğ¢ğ©ğ¡ğ¨ğ§ğğ«ğ¨ğ­ğ¨ğœğ¨ğ¥", psi)
Shahriar_X_Fahim("ğ‡ğ–ğˆğƒ", hwid)
Shahriar_X_Fahim("ğ„ğ±ğ©ğ¢ğ«ğšğ­ğ¢ğ¨ğ§", life)

if message ~= "" then
  message = message .. final
  gg.alert(message, 'ğ‚ğğğ˜ & ğ„ğ—ğˆğ“')
  gg.copyText(message, false)
end

local f = io.open("/sdcard/hc_3.txt", "w")
f:write(message)

gg.clearResults()
  end


function V2RAY2()

--t.me/Shhriar_X_Fahim

limit = false
targetInfo = gg.getTargetInfo()
gg.clearResults()
app = targetInfo.packageName
local utf8 = {}
local bit = {
  data32 = {}
}
do
  do
    for SRD1_5_ = 1, 32 do
      bit.data32[SRD1_5_] = 2 ^ (32 - SRD1_5_)
    end
  end
end
local toby = string.byte
function utf8.charbytes(s, i)
  i = i or 1
  local c = string.byte(s, i)
  if c > 0 and c <= 127 then
    do return 1 end
    return
  end
  if c >= 194 and c <= 223 then
    do return 2 end
    return
  end
  if c >= 224 and c <= 239 then
    do return 3 end
    return
  end
  if c >= 240 and c <= 244 then
    return 4
  end
  return 1
end

local ded
function bit:d2b(arg)
  if arg == nil then
    return
  end
  local tr, c = {}, arg < 0
  if c then
    arg = 0 - arg
  end
  do
    do
      for SRD1_7_ = 1, 32 do
        if arg >= self.data32[SRD1_7_] then
          tr[SRD1_7_] = 1
          arg = arg - self.data32[SRD1_7_]
        else
          tr[SRD1_7_] = 0
        end
      end
    end
  end
  if c then
    tr = self:_bnot(tr)
    tr = self:b2d(tr) + 1
    tr = self:d2b(tr)
  end
  return tr
end
---Blue And Desert @DecryptConfig Project

function bit:b2d(arg, neg)
  local nr = 0
  if arg[1] == 1 and neg == true then
    arg = self:_bnot(arg)
    nr = self:b2d(arg) + 1
    nr = 0 - nr
  else
    do
      for SRD1_7_ = 1, 32 do
        if arg[SRD1_7_] == 1 then
          nr = nr + 2 ^ (32 - SRD1_7_)
        end
      end
    end
  end
  return nr
end
function bit:_and(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 and op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_or(a, b)
  local op1 = self:d2b(a)
  local op2 = self:d2b(b)
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == 1 or op2[SRD1_9_] == 1 then
          r[SRD1_9_] = 1
        else
          r[SRD1_9_] = 0
        end
      end
    end
  end
  return self:b2d(r, true)
end

function bit:_xor(a, b)
  local op1 = self:d2b(a)
  if op1 == nil then
    return nil
  end
  local op2 = self:d2b(b)
  if op2 == nil then
    return nil
  end
  local r = {}
  do
    do
      for SRD1_9_ = 1, 32 do
        if op1[SRD1_9_] == op2[SRD1_9_] then
          r[SRD1_9_] = 0
        else
          r[SRD1_9_] = 1
        end
      end
    end
  end
  return self:b2d(r, true)
end

local switch = {
  [1] = function(s, pos)
    local c1 = toby(s, pos)
    return c1
  end
  ,
  [2] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local int1 = bit:_and(31, c1)
    local int2 = bit:_and(63, c2)
    return bit:_or(bit:_lshift(int1, 6), int2)
  end
  ,
  [3] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local o2 = bit:_or(bit:_lshift(int1, 12), bit:_lshift(int2, 6))
    local dt = bit:_or(o2, int3)
    return dt
  end
  ,
  [4] = function(s, pos)
    local c1 = toby(s, pos)
    local c2 = toby(s, pos + 1)
    local c3 = toby(s, pos + 2)
    local c4 = toby(s, pos + 3)
    local int1 = bit:_and(15, c1)
    local int2 = bit:_and(63, c2)
    local int3 = bit:_and(63, c3)
    local int4 = bit:_and(63, c4)
    local o2 = bit:_or(bit:_lshift(int1, 18), bit:_lshift(int2, 12))
    local o3 = bit:_or(o2, bit:_lshift(int3, 6))
    local o4 = bit:_or(o3, int4)
    return o4
  end
  
}
function bit:_bnot(op1)
  local r = {}
  do
    do
      for SRD1_6_ = 1, 32 do
        if op1[SRD1_6_] == 1 then
          r[SRD1_6_] = 0
        else
          r[SRD1_6_] = 1
        end
      end
    end
  end
  return r
end

function bit:_not(a)
  local op1 = self:d2b(a)
  local r = self:_bnot(op1)
  return self:b2d(r, true)
end

function bit:charCodeAt(s)
  local pos, int, H, L = 1, 0, 0, 0
  local slen = string.len(s)
  local allByte = {}
  while pos <= slen do
    local tLen = utf8.charbytes(s, pos)
    if tLen >= 1 and tLen <= 4 then
      if tLen == 4 then
        int = switch[4](s, pos)
        H = math.floor((int - 65536) / 1024) + 55296
        L = (int - 65536) % 1024 + 56320
        table.insert(allByte, H)
        table.insert(allByte, L)
      else
        int = switch[tLen](s, pos)
        table.insert(allByte, int)
      end
    end
    pos = pos + tLen
  end
  return allByte
end

function bit:_rshift(a, n)
  local r = 0
  if a < 0 then
    r = 0 - self:_frshift(0 - a, n)
  elseif a >= 0 then
    r = self:_frshift(a, n)
  end
  return r
end

function bit:_frshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  local left = 32 - n
  if n < 32 and n > 0 then
    do
      for SRD1_9_ = left, 1, -1 do
        r[SRD1_9_ + n] = op1[SRD1_9_]
      end
    end
  end
  return self:b2d(r)
end

function bit:_lshift(a, n)
  local op1 = self:d2b(a)
  local r = self:d2b(0)
  if n < 32 and n > 0 then
    do
      for SRD1_8_ = n, 31 do
        r[SRD1_8_ - n + 1] = op1[SRD1_8_ + 1]
      end
    end
  end
  return self:b2d(r, true)
end

function trim(s)
  return s:match("^%s*(.*)"):match("(.-)%s*$")
end

local json = {}
local kind_of = function(obj)
  if type(obj) ~= "table" then
    return type(obj)
  end
  local i = 1
  do
    do
      for SRD1_5_ in pairs(obj) do
        if obj[i] ~= nil then
          i = i + 1
        else
          return "table"
        end
      end
    end
  end
  if i == 1 then
    do return "table" end
    return
  end
  return "array"
end

local escape_str = function(s)
  local in_char = {
    "\\",
    "\"",
    "/",
    "\b",
    "\f",
    "\n",
    "\r",
    "\t"
  }
  local out_char = {
    "\\",
    "\"",
    "/",
    "b",
    "f",
    "n",
    "r",
    "t"
  }
  do
    do
      for SRD1_6_, SRD1_7_ in ipairs(in_char) do
        s = s:gsub(SRD1_7_, "\\" .. out_char[SRD1_6_])
      end
    end
  end
  return s
end

local skip_delim = function(str, pos, delim, err_if_missing)
  pos = pos + #str:match("^%s*", pos)
  if str:sub(pos, pos) ~= delim then
    if err_if_missing then
      error("Esperado " .. delim .. " posiÃ§Ã£o prÃ³xima " .. pos)
    end
    return pos, false
  end
  return pos + 1, true
end

local function parse_str_val(str, pos, val)
  val = val or ""
  local early_end_error = "Fim da entrada encontrado durante a anÃ¡lise da string."
  if pos > #str then
    error(early_end_error)
  end
  local c = str:sub(pos, pos)
  if c == "\"" then
    return val, pos + 1
  end
  if c ~= "\\" then
    return parse_str_val(str, pos + 1, val .. c)
  end
  local esc_map = {
    b = "\b",
    f = "\f",
    n = "\n",
    r = "\r",
    t = "\t"
  }
  local nextc = str:sub(pos + 1, pos + 1)
  if not nextc then
    error(early_end_error)
  end
  return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

local parse_num_val = function(str, pos)
  local num_str = str:match("^-?%d+%.?%d*[eE]?[+-]?%d*", pos)
  local val = tonumber(num_str)
  if not val then
    error("Erro ao analisar o nÃºmero na posiÃ§Ã£o " .. pos .. ".")
  end
  return val, pos + #num_str
end

function json.stringify(obj, as_key)
  local s = {}
  local kind = kind_of(obj)
  if kind == "array" then
    if as_key then
      error("NÃ£o Ã© possÃ­vel codificar array como chave.")
    end
    s[#s + 1] = "["
    do
      do
        for SRD1_7_, SRD1_8_ in ipairs(obj) do
          if SRD1_7_ > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "]"
  elseif kind == "table" then
    if as_key then
      error("NÃ£o Ã© possÃ­vel codificar a tabela como chave.")
    end
    s[#s + 1] = "{"
    do
      do
        for SRD1_7_, SRD1_8_ in pairs(obj) do
          if #s > 1 then
            s[#s + 1] = ", "
          end
          s[#s + 1] = json.stringify(SRD1_7_, true)
          s[#s + 1] = ":"
          s[#s + 1] = json.stringify(SRD1_8_)
        end
      end
    end
    s[#s + 1] = "}"
  else
    if kind == "string" then
      do return "\"" .. escape_str(obj) .. "\"" end
      return
    end
    if kind == "number" then
      if as_key then
        return "\"" .. tostring(obj) .. "\""
      end
      do return tostring(obj) end
      return
    end
    if kind == "boolean" then
      do return tostring(obj) end
      return
    end
    if kind == "nil" then
      do return "null" end
      return
    end
    error("tipo unjsonificÃ¡vel,: " .. kind .. ".")
  end
  return table.concat(s)
end

json.null = {}
function json.parse(str, pos, end_delim)
  pos = pos or 1
  if pos > #str then
    error("Atingiu o fim inesperado da entrada ")
  end
  local pos = pos + #str:match("^%s*", pos)
  local first = str:sub(pos, pos)
  if first == "{" then
    do
      local obj, key, delim_found = {}, true, true
      pos = pos + 1
      while true do
        key, pos = json.parse(str, pos, "}")
        if key == nil then
          return obj, pos
        end
        if not delim_found then
          error("VÃ­rgula faltando entre os itens do objeto.")
        end
        pos = skip_delim(str, pos, ":", true)
        obj[key], pos = json.parse(str, pos)
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "[" then
    do
      local arr, val, delim_found = {}, true, true
      pos = pos + 1
      while true do
        val, pos = json.parse(str, pos, "]")
        if val == nil then
          return arr, pos
        end
        if not delim_found then
          error("Falta vÃ­rgula entre os itens do array.")
        end
        arr[#arr + 1] = val
        pos, delim_found = skip_delim(str, pos, ",")
      end
    end
    return
  end
  if first == "\"" then
    do return parse_str_val(str, pos + 1) end
    return
  end
  if first == "-" or first:match("%d") then
    do return parse_num_val(str, pos) end
    return
  end
  if first == end_delim then
    do return nil, pos + 1 end
    return
  end
  do
    local literals = {
      ["true"] = true,
      ["false"] = false,
      null = json.null
    }
    do
      do
        for SRD1_9_, SRD1_10_ in pairs(literals) do
          local lit_end = pos + #SRD1_9_ - 1
          if str:sub(pos, lit_end) == SRD1_9_ then
            return SRD1_10_, lit_end + 1
          end
        end
      end
    end
    local pos_info_str = "position " .. pos .. ": " .. str:sub(pos, pos + 10)
    error("Sintaxe json invÃ¡lida comeÃ§ando em " .. pos_info_str)
  end
end

function enc(data, b)
  return (data:gsub(".", function(x)
    local r, b = "", x:byte()
    do
      do
        for SRD1_6_ = 8, 1, -1 do
          r = r .. (b % 2 ^ SRD1_6_ - b % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
    if #x < 6 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 6 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (6 - SRD1_5_) or 0)
        end
      end
    end
    return b:sub(c + 1, c + 1)
  end
  ) .. ({
    "",
    "??",
    "?"
  })[#data % 3 + 1]
end

function dec(data, b)
  data = string.gsub(data, "[^" .. b .. "=]", "")
  return (data:gsub(".", function(x)
    if x == "?" then
      return ""
    end
    local r, f = "", b:find(x) - 1
    do
      do
        for SRD1_6_ = 6, 1, -1 do
          r = r .. (f % 2 ^ SRD1_6_ - f % 2 ^ (SRD1_6_ - 1) > 0 and "1" or "0")
        end
      end
    end
    return r
  end
  ):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
    if #x ~= 8 then
      return ""
    end
    local c = 0
    do
      do
        for SRD1_5_ = 1, 8 do
          c = c + (x:sub(SRD1_5_, SRD1_5_) == "1" and 2 ^ (8 - SRD1_5_) or 0)
        end
      end
    end
    return string.char(c)
  end
  ))
end
function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, endereÃ§o fornecido Ã© nulo.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("NÃ£o foi possÃ­vel transmitir '" .. tostring(number) .. "' enumerar.'"))
end
  local load ='LOADING: '
  
function save(data)
io.open("/sdcard/v2ğŸ‡§ğŸ‡©.txt", "w"):write(data)
  gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
  for i = 1, 5 do
load = load..'â—‰â€¿â—‰'
gg.toast(load)
gg.sleep(1)
end
end

function save2(data)
  io.open(gg.EXT_STORAGE .. "/sdcard/v2ğŸ‡§ğŸ‡©.txt", "w"):write(json.stringify(data))
  gg.toast("!")
end

function rwmem(Address, SizeOrBuffer)
	assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
	_rw = {}


	if type(SizeOrBuffer) == "number" then
		_ = ""
		for _ = 1, SizeOrBuffer do _rw[_] = {address = (Address - 1) + _, flags = gg.TYPE_BYTE} end
		for v, __ in ipairs(gg.getValues(_rw)) do
			if __.value == 00 and limit == true then
		return _
		end
		_ = _ .. string.format("%02X", __.value & 0xFF)
		
end
		return _
	end
	Byte = {} SizeOrBuffer:gsub("..", function(x)
		Byte[#Byte + 1] = x _rw[#Byte] = {address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h"}	end)
    gg.setValues(_rw)
end


  gg.clearResults()
  gg.setVisible(false)
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_PPSSPP | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_BAD)
  gg.setSpeed(20.0)
  gg.setVisible(false)
  gg.searchNumber("h 7B 0A 09 09 22 69 6E 62 6F 75 6E 64", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("inbounds")
    hc_2 = true
  end
  if hc_2 then 
    gg.searchNumber("h 7B 0A 09 09 22 64 6E 73 22", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("dns")
      hc_3 = true
    end
  end
  if hc_3 then
    gg.searchNumber("h 20 22 64 6e 73 22 3a 20 7b", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_4 = true
    end
  end
  if hc_4 then
    gg.searchNumber("h 7B 0A 09 09 09 09 09 09 09 09 09 09 09 09 22 61 64 64 72 65 73 73 22 3A", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("address")
      hc_5 = true
    end
  end
  if hc_5 then
    gg.searchNumber("h 22 6c 6f 67 22 3a", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
      gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
      hc_6 = true
    end
  end
  if hc_6 then
    gg.searchNumber("h 22 6f 75 74 62 6f 75 6e 64 73", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
  local r = gg.getResults(1)
  if #r < 1 then
    gg.toast("outbounds")
      hc_7 = true
    end
  end
  if hc_7 then
    gg.toast("â§¼ ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğšğ¡ğ¢ğ¦ â§½")
    print("all metode failed\n")
    os.exit()
  end
  local r = gg.getResults(1000)
  if limit == false then
    r[1].address = r[1].address - 0x400
  end
readedMem = rwmem(r[3].address, 50000)
save(hexdecode(readedMem))
gg.clearResults()

local f = io.open("/sdcard/v2ğŸ‡§ğŸ‡©.txt", "r")
 local content = f:read(3000)
 content= content:gsub("%c","")
 f:close()

---Blue And Desert @DecryptConfig Project

 local muxEnabled = content:match('"mux"%s*:%s*{[^}]-"enabled"%s*:%s*(%a+)')
  local address = content:match('"address"%s*:%s*"(.-)"')
 local protocol = content:match('"protocol"%s*:%s*"([^"]+)"')
 local address = content:match('"address"%s*:%s*"(.-)"')
 local port = tonumber(content:match('"port"%s*:%s*(%d+)'))
 local alterId = tonumber(content:match('"alterId"%s*:%s*(%d+)'))
 local id = content:match('"id"%s*:%s*"(.-)"')
 local level = tonumber(content:match('"level"%s*:%s*(%d+)'))
 local security = content:match('"security"%s*:%s*"([^"]+)"')
 local network = content:match('"network"%s*:%s*"([^"]+)"')
 local host = content:match('"Host"%s*:%s*"(.-)"')
 local path = content:match('"path"%s*:%s*"(.-)"')
 local tag = content:match('"tag"%s*:%s*"(.-)"')
 local connIdle = tonumber(content:match('"connIdle"%s*:%s*(%d+)'))
 local downlinkOnly = tonumber(content:match('"downlinkOnly"%s*:%s*(%d+)'))
 local handshake = tonumber(content:match('"handshake"%s*:%s*(%d+)'))
 local uplinkOnly = tonumber(content:match('"uplinkOnly"%s*:%s*(%d+)'))
 local allowInsecure = content:match('"allowInsecure"%s*:%s*(%a+)')
 local serverName = content:match('"serverName"%s*:%s*"(.-)"')
 
 
 local result = {
[1] = {
      ['name'] = 'â”‚[â˜†] ğğ«ğ¨ğ­ğ¨ğœğ¨ğ¥',
      ['regex'] = protocol,
    },
[2] = {
      ['name'] = 'â”‚[â˜†] ğ’ğğ«ğ¯ğğ«ğ€ğğ«ğğ¬ğ¬',
      ['regex'] = address,
    },
[3] = {
      ['name'] = 'â”‚[â˜†] ğğ¨ğ«ğ­',
      ['regex'] = port,
    },
[4] = {
      ['name'] = 'â”‚[â˜†] ğ€ğ¥ğ­ğğ«ğˆğƒ',
      ['regex'] = alterId,
    },
[5] = {
      ['name'] = 'â”‚[â˜†] ğˆğƒ',
      ['regex'] = id,
    },
[6] = {
      ['name'] = 'â”‚[â˜†] ğ‹ğğ¯ğğ¥',
      ['regex'] = level,
    },
[7] = {
      ['name'] = 'â”‚[â˜†] ğ’ğğœğ®ğ«ğ¢ğ­ğ²',
      ['regex'] = security,
    },
[8] = {
      ['name'] = 'â”‚[â˜†] ğğğ­ğ°ğ¨ğ«ğ¤',
      ['regex'] = network
    },
[9] = {
      ['name'] = 'â”‚[â˜†] ğ“ğ‹ğ’ğ’ğğœğ®ğ«ğ¢ğ­ğ²',
      ['regex'] = tlssecurity,
    },
[10] = {
      ['name'] = 'â”‚[â˜†] ğ€ğ¥ğ¥ğ¨ğ°ğˆğ§ğ¬ğğœğ®ğ«ğ',
      ['regex'] = allowInsecure,
    },
[11] = {
      ['name'] = 'â”‚[â˜†] ğ’ğğ«ğ¯ğğ«ğğšğ¦ğ',
      ['regex'] = serverName,
    },
[12] = {
      ['name'] = 'â”‚[â˜†] ğ‡ğ¨ğ¬ğ­',
      ['regex'] = host,
    },
[13] = {
      ['name'] = 'â”‚[â˜†] ğğšğ­ğ¡',
      ['regex'] = path,
    },
[14] = {
      ['name'] = 'â”‚[â˜†] ğ“ğšğ ',
      ['regex'] = tag,
    },
[15] = {
      ['name'] = 'â”‚[â˜†] ğ‚ğ¨ğ§ğ§ğ¢ğğ¥ğ',
      ['regex'] = connIdle,
    },
[16] = {
      ['name'] = 'â”‚[â˜†] ğƒğ¨ğ°ğ§ğ‹ğ¢ğ§ğ¤ğğ§ğ¥ğ²',
      ['regex'] = downlinkOnly,
    },
[17] = {
      ['name'] = 'â”‚[â˜†] ğ‡ğšğ§ğğ’ğ¡ğšğ¤ğ',
      ['regex'] = handshake,
    },
[18] = {
      ['name'] = 'â”‚[â˜†] ğ”ğ©ğ‹ğ¢ğ§ğ¤ğğ§ğ¥ğ²',
      ['regex'] = uplinkOnly,
    },
}
 
  ---@Shahriar_X_Fahim 
  
  
    local message = "```sql\nâ”Œâ”€[ @Shahriar_X_Fahim ] \nâ”Šâ§¼ ğ’®ğ’½ğ’¶ğ’½ğ“‡ğ’¾ğ“‡_ğ’³_â„±ğ’¶ğ’½ğ’¾ğ“‚ â§½\nâ”‚â§¼ ğ•2ğ‘ğ€ğ˜ ğ€ğ‹ğ‹ â§½\nâ”œâ”€â”€â”€â•¼[ t.me/Decrypt_VPN_Files ]\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n" .. '\n'
  

message = message .. 'â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n'

 for i, v in ipairs(result) do
  if result[i] and result[i]['regex'] then
    message = message..result[i]['name'].." â‰«ï¸ ' "..''..''..result[i]['regex']..''.." ' \nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"

end
end


message = message .. 'â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n'

  message = message .. 'â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[â˜†] ğƒğğœ ğğ² : @Shahriar_X_Fahim\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```'
 

    
    
    
    
    

  
 gg.copyText(message, false)
 gg.alert(message, "ğ‚ğğğ˜")
-- gg.toast(message .. [[

--]])

io.open("/sdcard/ResultğŸ‡§ğŸ‡©.txt", "w"):write(message)
gg.isVisible(true)
 gg.clearResults()
end


function darktunnel2()
-- Function to read and write memory
function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is null.")

  local _rw = {}

  if type(SizeOrBuffer) == "number" then
    local result = ""
    for i = 1, SizeOrBuffer do
      _rw[i] = {
        address = Address - 1 + i,
        flags = gg.TYPE_BYTE
      }
    end

    for _, value in ipairs(gg.getValues(_rw)) do
      if value.value == 0 and limit == true then
        return result
      end
      result = result .. string.format("%02X", value.value & 255)
    end

    return result
  end

  local Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end)

  gg.setValues(_rw)
end

-- Function to decode hexadecimal to string
function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end))
end

-- Function to clean and filter non-printable characters
function cleanText(str)
  return (str:gsub("[\0-\31\127]", ""))
end

-- Manually format JSON with indentation
function formatJsonManually(jsonText)
  local indent = 0
  local formatted = ""
  local inString = false
  local prevChar = ""

  -- Loop through each character and add indentation
  for i = 1, #jsonText do
    local currentChar = jsonText:sub(i, i)

    if currentChar == '"' and prevChar ~= "\\" then
      inString = not inString
    end

    if inString then
      formatted = formatted .. currentChar
    else
      if currentChar == "{" or currentChar == "[" then
        formatted = formatted .. currentChar .. "\n"
        indent = indent + 1
        formatted = formatted .. string.rep("  ", indent)
      elseif currentChar == "}" or currentChar == "]" then
        formatted = formatted .. "\n"
        indent = indent - 1
        formatted = formatted .. string.rep("  ", indent) .. currentChar
      elseif currentChar == "," then
        formatted = formatted .. currentChar .. "\n"
        formatted = formatted .. string.rep("  ", indent)
      else
        formatted = formatted .. currentChar
      end
    end

    prevChar = currentChar
  end

  return formatted
end

-- Save data to a file
function save(data)
  local file = io.open("/sdcard/decrypt.txt", "w")
  file:write(data)
  file:close()
end

-- Main function that controls the decryption process
  limit = true
  gg.clearResults()
  gg.setVisible(true)
  gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_C_HEAP | gg.REGION_C_DATA)

  -- Function to search and save specific data
  local function searchAndSave(searchText)
    gg.searchNumber(searchText, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local result = gg.getResults(1)

    if #result > 0 then
      if limit == false then
        result[1].address = result[1].address - 8192
      end
      local readedMem = rwmem(result[1].address, 10000)
      save(hexdecode(readedMem))
      return true
    end

    return false
  end

  -- List of tests with specific byte patterns
  local tests = {
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22 2C',
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22 2C',
    'h 7B 22 69 6E 62 6F 75 6E 64 73 22 3A 5B 7B 22 6C 69 73 74 65 6E 22 3A 22 31 32 37 2E 30 2E 30 2E 31 22',
    'h 3a 56 65 72 73 69 6f 6e 43 6f 64 65',
  }

  -- Attempt to search and save one of the tests
  local addressFound = false

  for _, searchText in ipairs(tests) do
    if searchAndSave(searchText) then
      addressFound = true
      break
    end
  end

  -- If no address is found, show an alert and exit
  if not addressFound then
    gg.alert("Decryption failed. Re-import the file and run the script.")
    os.exit()
  end

  -- Read the decrypted data from the file
  local file = io.open("/sdcard/decrypt.txt", "r")
  local dark = file:read("*all")
  file:close()

  -- Clean the text (remove non-printable characters)
  dark = cleanText(dark)

  -- If it's JSON-like data, format it manually
  if dark:sub(1, 1) == "{" or dark:sub(1, 1) == "[" then
    dark = formatJsonManually(dark)
  end

  -- Prepare the header
  local header = [[
```yaml
â”Œâ”€â”€â€¢â€â€¢â€  ğ˜¿ğ™–ğ™§ğ™  ğ™ğ™ğ™‰ğ™‰ğ™€ğ™‡  â€â€¢â€â€¢â”€â”€â”
â”œâ¢ ğ˜¾ğ™¤ğ™™ğ™š ğ˜½ğ™® : [ğ’ğ¡ğšğ¡ğ«ğ¢ğšğ«_ğ—_ğ…ğ€ğ‡ğˆğŒ]
â”œâ¢ ğ™ğ™‚ : t.me/Decrypt_VPN_Files
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â””â”ˆâ¤  ğ™‘2ğ™§ğ™–ğ™® : 
]]

  -- Prepare the footer
  local footer = [[
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”œâ”ˆâ¤ ğ——ğ—²ğ—°ğ—¿ğ˜†ğ—½ğ˜ ğ—•ğ˜† : @Shahriar_X_Fahim
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
]]

  -- Wrap the JSON data with the "Json" markers
  local jsonWrapped = "\n" .. dark .. "\n"

  -- Combine header, JSON wrapped data, and footer
  local message = header .. "\n" .. jsonWrapped .. "\n" .. footer

  -- Save the combined message to the file
  save(message)

  -- Copy text including header, formatted JSON, and footer
  gg.alert(message, 'ğ‚ğğğ˜ ğ€ğğƒ ğ„ğ—ğˆğ“')
  gg.copyText(message, false)

  -- Save the message to the file
  save(message)

  -- Hide GameGuardian interface
  gg.setVisible(false)

-- Call the DarkTunnel function to execute the script
  gg.clearResults()
end








function tls()

function rwmem(Address, SizeOrBuffer)
  assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
  _rw = {}
  if type(SizeOrBuffer) == "number" then
    _ = ""
    do
      do
        for SRD1_5_ = 1, SizeOrBuffer do
          _rw[SRD1_5_] = {
            address = Address - 1 + SRD1_5_,
            flags = gg.TYPE_BYTE
          }
        end
      end
    end
    do
      do
        for SRD1_5_, SRD1_6_ in ipairs(gg.getValues(_rw)) do
          if SRD1_6_.value == 0 and limit == true then
            return _
          end
          _ = _ .. string.format("%02X", SRD1_6_.value & 255)
        end
      end
    end
    return _
  end
  Byte = {}
  SizeOrBuffer:gsub("..", function(x)
    Byte[#Byte + 1] = x
    _rw[#Byte] = {
      address = Address - 1 + #Byte,
      flags = gg.TYPE_BYTE,
      value = x .. "h"
    }
  end
  )
  gg.setValues(_rw)
end

function hexdecode(hex)
  return (hex:gsub("%x%x", function(digits)
    return string.char(tonumber(digits, 16))
  end
  ))
end

function hexencode(str)
  return (str:gsub(".", function(char)
    return string.format("%2x", char:byte())
  end
  ))
end

function Dec2Hex(nValue)
  nHexVal = string.format("%X", nValue)
  sHexVal = nHexVal .. ""
  return sHexVal
end

function ToInteger(number)
  return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open("results.txt", "w"):write(data)
end
  limit = false
    gg.clearResults()
    gg.setVisible(false)
    gg.processPause()
    gg.searchNumber(':{"A":', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
    local r = gg.getResults(1)
    if #r < 1 then
        tls_2 = true
    end
    if tls_2 then
        gg.searchNumber(':"z":"', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_3 = true
        end
    end
    if tls_3 then
        gg.searchNumber(':"z":"', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_4 = true
        end
    end
        if tls_4 then
        gg.searchNumber(':" z " : " ', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_5 = true
        end
    end
        if tls_5 then
        gg.searchNumber(':" z " : " ', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_6 = true
        end
    end
    if tls_6 then
    gg.searchNumber(':" z " : " ', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
        local r = gg.getResults(1)
        if #r < 1 then
            tls_7 = true
        end
    end
    if tls_7 then
        gg.processResume()
    gg.alert("Decryption failed re-import the file and run the script")
    gg.toast("â‘  ğƒğğœğ«ğ²ğ©ğ­ ğ…ğšğ¢ğ¥ğğ!  â‘") 
    gg.processResume()
    os.exit()
  end
      local r = gg.getResults(1)
  if limit == false then
    r[1].address = r[1].address +100
    end
  readedMem = rwmem(r[1].address, 8000)
  save(hexdecode(readedMem))
  gg.processResume()
  gg.clearResults()

local f = io.open("results.txt", "r")
local content = f:read("*all")
f:close()

content = content:gsub("[%z\1-\31\127-\159\226\128-\235]", '')

local f = io.open("results.txt", "w")
 f:write(content)
 f:close()

local startMessage = "```makefile\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚' â§¼ ğƒğ„ğ‚ğ‘ğ˜ğğ“ ğ“ğ‹ğ’ ğ“ğ”ğğğ„ğ‹ â§½'\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ©] ğ†ğ«ğ¨ğ®ğ© :' t.me/Decrypt_VPN_Files '\n"
local endMessage = "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ©] ğƒğğœ ğğ² : '@Shahriar_X_Fahim '\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"

local A = content:match('"A":(%a+)')
local B = content:match('"B":(%a+)')
local C = content:match('"C":(%a+)')
local D = content:match('"D":"(.-)"')
local E = content:match('"E":(%a+)')
local F = content:match('"F":(%a+)')
local a = content:match('"a":(%a+)')
local b = content:match('"b":(%d+)')
local c = content:match('"c":(%d+)')
local d = content:match('"d":(%d+)')
local e = content:match('"e":(%a+)')
local f = content:match('"f":"(.-)"')
local g = content:match('"g":"(.-)"')
local h = content:match('"h":"(.-)"')
local i = content:match('"i":"(.-)"')
local j = content:match('"j":"(.-)"')
local k = content:match('"k":"(.-)"')
local l = content:match('"l":(%d+)')
local m = content:match('"m":(%a+)')
local n = content:match('"n":"(.-)"')
local o = content:match('"o":(%a+)')
local p = content:match('"p":"(.-)"')
local q = content:match('"q":(%a+)')
local r = content:match('"r":"(.-)"')
local s = content:match('"s":(%a+)')
local t = content:match('"t":"(.-)"')
local u = content:match('"u":"(.-)"')
local v = content:match('"v":(%d+)')
local w = content:match('"w":"(.-)"')
local x = content:match('"x":"(.-)"')
local y = content:match('"y":"(.-)"')
local z = content:match('"z":"(.-)"')

local alertMessage = startMessage

-- FunciÃ³n para agregar al mensaje de alerta
local function appendToAlert(label, value)
  if value and value ~= "" then
    alertMessage = alertMessage .. "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”‚[âœ©] " .. label .. " :'" .. value .. "'\n"
  end
end

appendToAlert("ğ’ğğ«ğ¯ğğ«", h)
appendToAlert("ğğ¨ğ«ğ­", i)
appendToAlert("ğ”ğ¬ğğ«ğ§ğšğ¦ğ", f)
appendToAlert("ğğšğ¬ğ¬ğ¨ğ°ğ«ğ", g)
appendToAlert("ğğ«ğ¢ğ¯ğğ­ ğ’ğğ«ğ¯ğğ«", j)
appendToAlert("ğğ«ğ¢ğ¯ğğ­ ğğ¨ğ«ğ­", k)
appendToAlert("ğğšğ²ğ¥ğ¨ğšğ", n)
appendToAlert("ğ’ğğˆ", p)
appendToAlert("ğğšğ²ğ¥ğ¨ğšğ ğ€ğŸğ­ğğ« ğ“ğ‹ğ’", r)
appendToAlert("ğ‚ğ¨ğ§ğ§ğğœğ­ğ¢ğ¨ğ§ ğ“ğ²ğ©ğ", s)
appendToAlert("ğ’ğğ«ğ¯ğğ« ğğ«ğ¨ğ±ğ²", t)
appendToAlert("ğğ¨ğ«ğ­", u)
appendToAlert("ğƒğğ’ ğ’ğğ«ğ¯ğğ«", w)
appendToAlert("ğƒğğ’ ğğ¨ğ«ğ­", x)
appendToAlert("ğ‘ğğªğ®ğğ¬ğ­ ğƒğ¨ğ¦ğšğ¢ğ§", y)
appendToAlert("ğğ®ğ›ğ¥ğ¢ğœ ğŠğğ²", z)
appendToAlert("ğ•ğğ«ğ¢ğ¨ğ§ ğ€ğ©ğ©", b)

if alertMessage ~= startMessage then
  alertMessage = alertMessage .. endMessage
  gg.alert(alertMessage, 'copy and exit')
  gg.copyText(alertMessage, false)
  gg.toast("â™  ğƒğğœğ«ğ²ğ©ğ­ ğ’ğ®ğœğœğğ¬ğ¬!  â™")
end

local file = io.open("Tls_Tunnel.txt", "w")
file:write(alertMessage)

  gg.setVisible(false)
  gg.clearResults()
end



function HTTP3()
  limit = false
function rwmem(Address, SizeOrBuffer)
    assert(Address ~= nil, "[rwmem]: error, provided address is nil.")
    _rw = {}
    if type(SizeOrBuffer) == "number" then
        _ = ""
        for _ = 1, SizeOrBuffer do _rw[_] = { address = (Address - 1) + _, flags = gg.TYPE_BYTE } end
        for v, __ in ipairs(gg.getValues(_rw)) do
            if __.value == 00 and limit == true then
                return _
            end
            _ = _ .. string.format("%02X", __.value & 0xFF)
        end
        return _
    end
    Byte = {}
    SizeOrBuffer:gsub("..", function(x)
        Byte[#Byte + 1] = x
        _rw[#Byte] = { address = (Address - 1) + #Byte, flags = gg.TYPE_BYTE, value = x .. "h" }
    end)
    gg.setValues(_rw)
end

function hexdecode(hex)
    return (hex:gsub("%x%x", function(digits) return string.char(tonumber(digits, 16)) end))
end

function hexencode(str)
    return (str:gsub(".", function(char) return string.format("%2x", char:byte()) end))
end

function Dec2Hex(nValue)
    nHexVal = string.format("%X", nValue)
    sHexVal = nHexVal .. ""
    return sHexVal
end

function ToInteger(number)
    return math.floor(tonumber(number) or error("Could not cast '" .. tostring(number) .. "' to number.'"))
end

function save(data)
    io.open(gg.EXT_STORAGE .. "/decrypt.txt", "w"):write(hexdecode(data))
end

gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_ANONYMOUS)
gg.setVisible(false)
gg.setSpeed(20.0)
gg.searchNumber(":[host]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then   
    hc_method2 = true
end
if hc_method2 then 
gg.searchNumber(":[crlf]", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method3 = true
end
end
if hc_method3 then 
gg.searchNumber(":inbounds", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method4 = true
end
end
if hc_method4 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method5 = true
end
end
if hc_method5 then 
gg.searchNumber(":# Config for OpenVPN 2.x", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method6 = true
end
end
if hc_method6 then 
gg.searchNumber(':[splitPsiphon', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method7 = true
end
end
if hc_method7 then 
gg.searchNumber(":443@", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method8 = true
end
end
if hc_method8 then 
gg.searchNumber(':["ey', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then    
    hc_method9 = true
end
end
if hc_method9 then 
gg.searchNumber(':FRONTED-', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 0, -1, 0)
local r = gg.getResults(1)
if #r < 1 then  
    hc_method10 = true
end


end
if hc_method10 then
gg.alert("KEYWORD NOT FOUND")
os.exit()
end

local r = gg.getResults(1000)
if limit == false then
    r[1].address = r[1].address - 0x200
end

readedMem = rwmem(r[1].address, 19000)
save(readedMem)
gg.clearResults()

local file = io.open("/sdcard/decrypt.txt", 'rb')
local content = file:read(20000)
file:close()
local sshfile = io.open("/sdcard/decrypt.txt", 'rb')
local sshcontent = sshfile:read(1000)
sshfile:close()

function obterEntradaSSH()
  local texto = gg.prompt({"Cole ssh criptografado: "}, nil, {"text"})
  
  if texto == nil then
    os.exit()
  end
  
  return texto[1]
end

function salvarTextoEmArquivo(texto, caminhoArquivo)
  if texto == nil or texto == "" then
    return nil, "Texto invÃ¡lido"
  end
  
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "w")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  arquivo:write(texto)
  arquivo:close()
  
  return true
end

function lerTextoDeArquivo(caminhoArquivo)
  if caminhoArquivo == nil or caminhoArquivo == "" then
    return nil, "Caminho de arquivo invÃ¡lido"
  end
  
  local arquivo = io.open(caminhoArquivo, "r")
  if arquivo == nil then
    return nil, "NÃ£o foi possÃ­vel abrir o arquivo"
  end
  
  local conteudo = arquivo:read("*all")
  arquivo:close()
  
  if conteudo == nil then
    return nil, "NÃ£o foi possÃ­vel ler o conteÃºdo do arquivo"
  end
  
  return conteudo
end

local hcRegex = {}
hcRegex["sshEnc"] = "([%w.-]-):(%d+)@([%d-.]+):([%d-.]+)"
hcRegex["sshNormal"] = "([%w.-]-):(%d+)@(%w+):(%w+)"

function save(val1, val2, val11, val22, val3, car)
    local outputFileName = "/sdcard/decrypt.txt"

    local outputFile = io.open(outputFileName, "a")

    if outputFile then
        local data = string.format("%s, %s, %s, %s, %s, %s\n", val1, val2, val11, val22, val3, car)
        outputFile:write(data)
        print("")
        outputFile:close()
    else
        print("Falha ao abrir o arquivo de saÃ­da")
    end
end

function bitwiseAntigo(val1, val2)
  return string.char((tonumber(val1) // (2 ^ tonumber(val2))) % 256)
end

function extract(data, iv)
  local new_data = ""
  for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
    local val11 = tonumber(val1) - iv
    local val22 = tonumber(val2) - iv
    local val3 = ((val11 // (2 ^ val22)) % 256)
    local car = string.char(val3)

    new_data = new_data .. car
  end
  if verificaString(new_data) then
    return new_data
  else
    new_data = ""
    for val1, val2 in string.gmatch(data, "(-?%d+)%.(-?%d+)") do
      car = bitwiseAntigo(val1, val2)
      new_data = new_data .. car
    end
    return new_data
  end
end

function verificaString(str)
  for i=1, #str do
    local char = str:sub(i,i)
    local ascii = string.byte(char)
    if ascii < 0 or ascii > 255 then
      return false
    end
  end
  return true
end

function calculaIv(user, senha)
  if type(user) ~= "string" or type(senha) ~= "string" then
    return nil, "UsuÃ¡rio e senha devem ser strings"
  end
  
  local countU = 0
  local countP = 0
  for match in user:gmatch("(-?%d+)%.(-?%d+)") do
    countU = countU + 1
  end
  for match in senha:gmatch("(-?%d+)%.(-?%d+)") do
    countP = countP + 1
  end   
  
  return countU, countP
end

function dec_user_pass(user, userIv, pasw, passIv)
    return extract(user, userIv), extract(pasw, passIv)
end

local function exibirEInserir(arquivoSaida, label, texto)
   
    local sucesso, erro = arquivoSaida:write(label .. ": " .. texto .. "\n\n")

    if not sucesso then
        print("Erro ao escrever no arquivo de saÃ­da: " .. erro)
    end
end

function processarSSHx()
    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt"

    local entradaSSH = lerTextoDeArquivo(caminhoArquivoEntrada)

    if not entradaSSH then
        print("Erro ao ler o arquivo de entrada")
        return
    end

    local sshHost, sshPort, sshU, sshP = string.match(entradaSSH, hcRegex["sshEnc"])

    if not sshHost or not sshPort or not sshU or not sshP then
        print("")
        return
    end

    local userIv, senhaIv = calculaIv(sshU, sshP)

    if not userIv or not senhaIv then
        print("Erro ao calcular as IVs")
        return
    end

    local sshUser, sshSenha = dec_user_pass(sshU, userIv, sshP, senhaIv)

    if not sshUser or not sshSenha then
        result = "No Encrypt"
        return
    end

    local arquivoSaida = io.open(caminhoArquivoSaida, "a")

    if not arquivoSaida then
        result = "No Encrypt"
        return
    end


local saida = "\nHost: \"" .. (sshHost or "") .. "\""
saida = saida .. "\nPort: \"" .. (sshPort or "") .. "\""
saida = saida .. "\nUsername: \"" .. (sshUser or "") .. "\""
saida = saida .. "\nPassword: \"" .. (sshSenha or "") .. "\""
host = (sshHost)
port = (sshPort)
hostt = (sshUser)
pas = (sshSenha)
result = (sshHost ..":".. sshPort .."@".. sshUser ..":".. sshSenha)
    exibirEInserir(arquivoSaida, " ", saida)
    
    arquivoSaida:close()
end    

processarSSHx()

function payloadSF()
function payload()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                teste = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "\n")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function payloadx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

        local keywordsPayload = {"PATCH%/", "crlf%]", "Upgrade:", "GET / HTTP%/", "User-Agent", "protocol%]", "lf%]Host:", "lf%host:", "%[host", "host:", "Host:", "%[app_", "%[r", "\\r", "\\n", "\\r\\n", "%[Protocol%]", "lf%]"}
        local labelPayload = "Payload"

        local encontrouPayload = tentarEncontrarPalavrasChave(conteudo, keywordsPayload, labelPayload)

        if encontrouPayload then
            print("")
        else
        end
    end

    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    payloadx()
end

payload()
end

payloadSF()

function ovpnSF()
function ovpn()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testedd = (texto) or false
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")


                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

    
    local function ovpnx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsOpenVPN = {"auth%-user%-pass", "dev tun", "%<ca%>", "%<%/ca%>"}
    local labelOpenVPN = "\nOpenVPN"

    
    local encontrouOpenVPN = tentarEncontrarPalavrasChave(conteudo, keywordsOpenVPN, labelOpenVPN)

    if encontrouOpenVPN then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    ovpnx()
end

ovpn()
end

ovpnSF()

function v2raySF()
function v2ray()
    local function removeNullBytes(texto)
        return texto:gsub("^[%z]+", ""):gsub("[%z]+$", "")
    end

    local function tentarEncontrarPalavrasChave(conteudo, palavrasChave, label)
        conteudo = removeNullBytes(conteudo)

        for _, palavraChave in ipairs(palavrasChave) do
            local inicio, fim = conteudo:find(palavraChave)

            if inicio then
                local inicioJSON = inicio
                local fimJSON = fim

                while inicioJSON > 1 and conteudo:sub(inicioJSON - 1, inicioJSON - 1) ~= "\0" do
                    inicioJSON = inicioJSON - 1
                end

                while fimJSON < #conteudo and conteudo:sub(fimJSON + 1, fimJSON + 1) ~= "\0" do
                    fimJSON = fimJSON + 1
                end

                local texto = conteudo:sub(inicioJSON, fimJSON)

               
                local pay = texto
                testeddd = (texto)
                local arquivoSaida = io.open("/sdcard/hc.txt", "a")

                if not arquivoSaida then
                    print("Falha ao abrir o arquivo de saÃ­da.")
                    return
                end

                arquivoSaida:write(label .. ": " .. texto .. "")
                arquivoSaida:close()

                return true
            end
        end

        return false
    end

   
    local function v2rayx()
        local arquivo = io.open("/sdcard/decrypt.txt", "rb")

        if not arquivo then
            print("Falha ao abrir o arquivo de entrada.")
            return
        end

        local conteudo = arquivo:read("*a")
        arquivo:close()

   local keywordsV2ray = {"inbounds", "outbounds", "vless:\\/\\/", "vmess:\\/\\/", "trojan:\\/\\/"}
    local labelV2ray = "[#] ğ•ğŸğ‘ğšğ²"

    
    local encontrouV2ray = tentarEncontrarPalavrasChave(conteudo, keywordsV2ray, labelV2ray)

    if encontrouV2ray then
        print("")
    else
    end
end


    local caminhoArquivoEntrada = "/sdcard/decrypt.txt"
    local caminhoArquivoSaida = "/sdcard/hc.txt" 

    v2rayx()
end

v2ray()
end

v2raySF()

local mode = {
"SSH â” Payload & V2ray",
"V2ray",
"SSH â” Payload",
"SSL â” SSH â” Direct",
"OpenVPN â” Payload",
"Payload â” OpenVPN",
"OpenVPN",
"V2ray â” Payload",
"SSH â” Direct",
"SSH â” Payload",
"Psiphon â” Payload",
"Payload",
}
local active_mode = ""
if pas and teste and proxy and testeddd then
active_mode = mode[1]
elseif testeddd then
active_mode = mode[2]
elseif host and teste then
active_mode = mode[3]
elseif sni and pas then
active_mode = mode[4]
elseif testedd then
active_mode = mode[5]
elseif teste and proxy and testedd then
active_mode = mode[6]
elseif testedd then
active_mode = mode[7]
elseif testeddd and teste then
active_mode = mode[8]
elseif pas then
active_mode = mode[9]
elseif SSH then
active_mode = mode[10]
elseif psiph and teste then
active_mode = mode[11]
elseif teste and proxy then
active_mode = mode[12]
else
active_mode = "";
end

local PAYLOADD = string.match(sshcontent, "[a-zA-Z]+[\x20]+.*[\x5bcrlf\x5d+].+")  or "*."
local user = {}
for i = 1, #PAYLOADD - 1 do
table.insert(user, PAYLOADD:sub(i,i))
end
PAYLOADD = table.concat(user, "")
local SSH = string.match(sshcontent, "[0-9a-zA-Zx\x2e\x2d]+:[%d]+@[%w\x2e\x2d]+:[%w]+.") 
local psiph = string.match(content, '[%S]+FRONTED')
local psi = string.match(content, '%FRONTED.-[%w]+[%S][%w]+') 
local server = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local dns = string.match(content, "[%w\x2e\x2d]+[\x2e]+[%w]+")
local proxy = string.match(content, "%w+.[%w\x2e]+[\x3a][%d]+") 
local life = string.match(content, "%d%d%d%d[\45]%d%d[\45]%d%d[\32]%d%d[\58]%d%d") or "lifeTime"
local sni = string.match(content, "[%w%.-]+:%d%d+[^ ]-\0([%w%.-]-%.[%w.-]-)\0") 
local versi = string.match(content, "645") or "645"
local xX = os.date("%d/%m/%Y %I:%M:%S")

local result = {
    [1] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—›ğ—¢ğ—¦ğ—§âœ“ : ",
    ['DATA'] = host
    },
    [2] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—£ğ—¢ğ—¥ğ—§âœ“ : ",
    ['DATA'] = port
    },
    [3] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—¨ğ—¦ğ—˜ğ—¥âœ“ : ",
    ['DATA'] = hostt
    },
    [4] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—£ğ—”ğ—¦ğ—¦âœ“ : ",
    ['DATA'] = pas
    },
    [5] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—£ğ—®ğ˜†ğ—¹ğ—¼ğ—®ğ—± : ",
    ['DATA'] = teste
    },
    [6] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—£ğ—¿ğ—¼ğ˜…ğ˜† : ",
    ['DATA'] = proxy
    },
	[7] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—¢ğ—½ğ—²ğ—»ğ—©ğ—£ğ—¡ : ",
    ['DATA'] = testedd
    },
    [8] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—¦ğ—¦ğ—› : ",
    ['DATA'] = SSH
    },
    [9] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—¦ğ—¦ğ—Ÿ : ",
    ['DATA'] = sni
    },
    [10] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—©2ğ—¿ğ—®ğ˜† : ",
    ['DATA'] = testeddd
    },
    [11] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—£ğ˜€ğ—¶ğ—½ğ—·ğ—¼ğ—» ğ—”ğ˜‚ğ˜ğ—µğ—¼ğ—¿ğ—¶ğ˜‡ğ—®ğ˜ğ—¶ğ—¼ğ—»",
    ['DATA'] = psiph
    },
    [12] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—£ğ˜€ğ—¶ğ—½ğ—µğ—¼ğ—» ğ—£ğ—¿ğ—¼ğ˜ğ—¼ğ—°ğ—¼ğ—¹",
    ['DATA'] = psi
    },
    [13] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—©ğ—²ğ—¿ğ˜€ğ—¶ğ—¼ğ—» : ",
    ['DATA'] = versi
    },
    [14] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—§ğ—¶ğ—ºğ—² : ",
    ['DATA'] = xX
    },
    [15] = {
    ['NAME'] = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ•°â”ˆâ¤ ğ—§ğ˜‚ğ—»ğ—»ğ—²ğ—¹ ğ—§ğ˜†ğ—½ğ—² :",
    ['DATA'] = active_mode
    },
 
  }
  
      local message = "```yaml\nâ•­â”€â€¢â€â€¢â€ ğ™ƒğ™ğ™ğ™‹ ğ˜¾ğ™ğ™ğ™ğ™Šğ™ˆ â€â€¢â€â€¢â”€â•®\nâ”œâ¢ t.me/Decrypt_VPN_Files\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n"
      for index, keys in ipairs(result) do
        if result[index] and result[index]['DATA'] then 
          local names = result[index]['NAME']
          local value = result[index]['DATA']
  
          message = message..""..names.." ' "..value.." ' \n"
           end
            end
        
            message = message.."â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ”œâ”ˆâ¤ ğ——ğ—²ğ—°ğ—¿ğ˜†ğ—½ğ˜ ğ—•ğ˜† : @Shahriar_X_Fahim\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â€¢â€¢â€¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```"
        local alert = gg.alert(message, "ğ‚ğğğ˜", "ğ„ğ—ğˆğ“")
        if alert == 1 then
        gg.copyText(message, false)

        elseif alert == 2 then
        end
      io.open('/sdcard/hc.txt', 'w'):write(message)
    save(hexdecode(readedMem))
  gg.clearResults()
  end








function LOBBY()
  
  gg.skipRestoreState()
  gg.setVisible(true)
  os.exit()
end

while true do
  if gg.isVisible(true) then
    LuaLibraryTool = 1
    gg.setVisible(false)
  end
  if LuaLibraryTool == 1 then
    HOME()
  end
end